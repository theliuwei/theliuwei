# 变量可变性

**概念**

Rust中的变量可以分为**可变变量**和**不可变变量**，通俗来说，就是变量的值是否允许修改，如果在内存中给变量分配完值之后，可以根据需要来修改这个值，那它就是可变变量，反之，不允许这个值再发生变更，那就是不可变变量。前者很容易理解，变量的值在不同场景下会发生变化，它为编程提供了灵活性；后者，也有存在的道理，通过不可变的限制，提供了编程的安全性，特别是在多线程环境下，也减少了一些运行时检查，在一定程度上提升运行性能。

注意：这里提到的是否可变指的是**变量的值**，而非变量的**数据类型**。另外，不可变变量这个特性并不是Rust特有的，在Java中也有类似的概念，比如String类型就是不可变变量，当对不可变对象的值进行了类似的修改操作时，本质上是创建了新的对象，而不是修改了这个不可变变量的值。

比喻



### Documentation

我们分别定义2个不同类型的变量，并尝试修改对应的值。



```solidity
1fn main() {
2    // x 为可变变量，mut即 mutable的意思，该修饰符修饰的变量允许改变
3    let mut x = 1;
4    println!("x = {}", x); 
5    x = 2;
6    println!("x = {}", x);
7
8    // y 为不可变变量，如果没有指定mut，则Rust默认为不可变
9    let y = 3;
10    println!("y = {}", y);
11    // 对不可变变量 y 重新赋值，Rust编译器会给出cannot assign twice to immutable variable y的错误提示
12    y = 4; 
13    println!("y = {}", y);
14}
```

### FAQExpand All

Q1：不可变变量有哪些好处？



Q2：如果把变量全部声明为不可变变量 or 可变变量，有什么影响？