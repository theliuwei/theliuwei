# Solana背景介绍

## 引文

在开始学习 Solana 之前，让我们先来了解 Solana 的历史。

## Solana的历史

2017年11月，Anatoly Yakovenko发表了一篇白皮书，介绍了“Proof of History”这一技术（我们会在后续章节详细介绍），用于在不信任彼此的计算机之间进行时间同步。Anatoly 有在高通、Mesosphere 和Dropbox 设计分布式系统的经验，他知道有了可靠的时钟，网络同步就会变得很简单，而简单的同步能让网络运行得非常快，只受网络带宽限制。

Anatoly 注意到像比特币和以太坊这样没有时钟的区块链系统只能达到每秒 15 次的交易速度，而如果希望搭建一个世界中心化支付系统（如Visa）则需要峰值65,000次每秒的交易速度。 没有时钟，很明显他们永远无法像 Visa 那样成为全球支付系统。当 Anatoly 解决了计算机之间时间不一致的问题时，他意识到这是将多年的分布式系统研究应用到区块链领域的关键。他的解决方案不仅提高了效率，而且速度提高了成千上万倍。

Anatoly 一开始是在自己的 Github 中使用 C 语言实现了 Solana 的原型。曾在高通与 Anatoly 一起合作的 Greg Fitzgerald 鼓励他以 Rust 语言重新编写这个项目。Anatoly 两周内就完成了迁移到 Rust 的工作，并把这个项目命名为 Loom。

2018年2月13日，Greg Fitzgerald 开始为 Anatoly 的白皮书创建开源实现的原型。2月28日，Greg 就发布了首个版本，这个版本在半秒内就可以验证和处理超过10,000个签名交易。不久之后，另一位之前在高通工作的同事 Stephen Akridge 展示了如何通过图形处理器来验证签名，大大提高了处理速度。Anatoly 邀请 Greg、Stephen 和其他三个人共同创办了一家名为 Loom 的公司。

同一个时候，一个基于以太坊的项目 Loom Network 出现了，很多人经常把两个项目搞混。Loom团队决定重新给这个项目取个名字。最后他们决定把这个项目叫做 Solana 以纪念他们在圣地亚哥北部小海滩 Solana Beach 工作和冲浪的三年。2018年3月28日，团队创建了Solana 的 GitHub，并把Greg Fitzgerald 创作的原型命名为Solana。

### 测验

Solana 区块链的创始人是 Anatoly Yakovenko 阿纳托利·雅科文科还是Vitalik Buterin 维塔利克·布特林

# Solana & 以太坊

## 引文

本节我们将探讨两大公链—— **Solana** 和**以太坊**的差异。了解它们的技术细节和生态系统的差异对于开发者、生态参与者来说至关重要。

本节是 Solana 内容的整体介绍，具体的细节会在接下来的章节展开。我们从共识机制、交易处理能力、交易费用、智能合约、账户、编程语言和开发友好性这几个方面进行介绍。

## 一、共识机制

**Solana**使用的是Proof of History (PoH)与Proof of Stake (PoS)的结合，使得网络能够达到**每秒数千笔**交易处理速度。PoH 是 Solana 独有的创新性机制，用于记录和验证区块的时间戳和顺序。PoH 通过在每个区块中引入时间证明，使得节点能够迅速达成共识，而无需等待整个网络确认。而 Solana 的 PoS 机制用于选择验证者。验证者是通过抵押一定数量的代币来参与网络验证的。持有更多代币的验证者有更大的机会被选中生成新的区块和验证交易。因此，PoH 确保区块的时间戳和顺序，PoS 则确保网络的安全性和抗攻击性，这使得 Solana 成为一个适用于高性能去中心化应用和高频交易场景的区块链平台。

**以太坊** 于2022 年 9 月完成了从Proof of Work (PoW)到Proof of Stake (PoS)的以太坊2.0版本升级，将保护以太坊安全所需的能源消耗减少了 **99.95%**，同时创建一个**更安全、碳成本更低的以太坊网络**。

## 二、交易处理能力

**Solana**支持对交易的并行处理，通过将交易分成多个子集，并将每个子集分配给不同的验证节点进行处理，从而实现交易的并行处理。这种方法可以显著提高交易吞吐量，同时保证交易的安全性和可靠性。Solana 的平均出块时间为 400 毫秒，平均每秒 2000+ 笔交易，在高负载时保持较低的交易费用。

**以太坊** 每笔交易串行执行，一笔交易执行完成再开始下一笔交易，状态依次更新，这也限制了以太坊吞吐量长期维持在每秒15笔～30笔，以牺牲性能换来安全性和一致性。不过以太坊交易处理能力的提升，主要是通过Layer2的Rollup方案来实现的，Rollup 将数百笔交易捆绑（“打包”）为以太坊网络上的单笔交易，能够将燃料费减少多达100倍，同时，24年初即将上线的 **Proto-Danksharding** 升级，会进一步降低 gas 费，提升交易吞吐量。

## 三、交易费用（Gas费）

**Solana**它的交易费用是根据交易的复杂度和大小动态计算的，这意味着，交易费用会根据交易的执行成本而变化，而不是根据网络上的交易量变化。Solana 的平均交易费用通常低于 0.01 美元，平均为 0.00025 美元，这使得进行小额交易更具成本效益。

**以太坊** 的交易费用因网络拥堵而波动，这是一种纯粹的市场机制，网络中交易拥堵情况下你的交易要想被确认，就需要支付高昂的手续费。目前一笔转账交易的手续费大概在 1 ～ 10 美元左右。但其EIP-1559升级引入了一种新的费用市场机制，旨在使费用更可预测。

## 四、智能合约

**Solana**中一切皆账户，它的智能合约（Solana 中称之为**程序**program，后续也统一使用“程序”这一术语）也是账户，但细分为**可执行账户**和**数据账户**，前者存储程序的代码，用来执行特定的逻辑，后者存储状态，即程序运行时的数据。这种分离的模式，使得程序的升级更加简单，因为程序本身无状态，可以直接升级为新的代码逻辑。

**以太坊** 的智能合约本身就包含了合约的逻辑代码，以及状态数据。因此合约部署之后，就不支持直接的升级，只能通过代理的方式间接升级，即重新部署一套合约代码，生成新的合约地址，代理再指向这个新的合约地址。

## 五、账户

**Solana**中一切皆账户，它的账户就像一个容器（或者电脑中的文件夹），可以包含程序代码、状态数据以及账户元数据。按照功能可划分为**可执行账户**和**数据账户**，前者为存储程序代码的账户，也称为程序账户。后者包括**普通用户账户**和其他非程序账户，这些账户存储了用户的余额、交易历史和其他相关数据，但它们本身不包含程序代码。对于熟悉以太坊账户的同学来说，这种划分方式也许有点奇怪，不过随着了解的深入，就会认识到 Solana 的单一账户模型，使得多个交易能够并行处理，这正是 Solana 高性能的基础。

**以太坊** 分为**EOA账户**和**智能合约**，前者是普通用户在以太坊网络中的账户，用于存储以太币（ETH）和进行交易。后者是包含智能合约代码和状态的账户，这些账户由合约创建并部署在以太坊区块链上。通过这两种账户类型的结合，以太坊提供了一个灵活且功能强大的去中心化应用开发平台。

## 六、编程语言和开发友好性

**Solana**支持包括Rust和C在内的多种编程语言，这些语言以高性能而闻名。

**以太坊** 的Solidity语言是为智能合约设计的，拥有大量的开发工具和广泛的开发者社区，这为新加入的开发者提供了丰富的资源和支持。

### 七、生态系统和用户基础

**Solana**正在快速建立其生态系统，但相对于以太坊来说还较新，存在很多机会。

**以太坊** 拥有最大的去中心化应用（DApp）生态系统，以及广泛的用户和开发者社区，这为其提供了强大的网络效应和更高的去中心化程度。

通过比较，我们会发现每个平台都有自己的优势和挑战。以太坊的广泛采用和成熟的生态系统为其提供了稳定性和信任，而 Solana 的高性能和低成本则为那些需要这些特性的应用提供了优势。

# Solana PoH

## 引文

上节我们对 Solana 链有了初步了解，本节我们继续学习 Solana 的共识机制。

![image](./assets/0be8d422-b309-4f45-8974-4fc9a60189ad.webp)

正如比特币创世区块中，中本聪留下了当天《泰晤士报》的头版头条文章——The Times 03/Jan/2009 Chancellor on brink of second bailout for banks。这证明了创世区块是在 2009 年 1月 3 日当天或者之后被矿工 mint。后续所有的比特币交易，也发生在这个时间节点之后。

那么，如果后续所有的交易（或者说事件），都是顺序的，并且加盖了 “时间戳” 的，事实上这就是一个基于时间的历史事件序列。我们要证明某个交易事件在这个序列中，只要从这个历史序列中去求证即可。

和许多加密应用使用的基础技术一样，这里也将使用 hash 函数将这个序列串联起来。

## Hash函数

Solana 的 POH 共识机制中使用的哈希函数是 SHA-256，这是一种安全哈希算法，它将任意长度的输入（也称为消息）转换为一个固定长度的输出。它的作用主要是为了确保网络的时间顺序性和安全性。这里我们看下 hash函数的一些重要特性：

1.每个不同的输入应该映射到**唯一**的哈希值，相反，从哈希值推导出原始输入数据应该是计算上不可行的。好的哈希函数应该是**单向**的，防止通过哈希值反向计算出原始数据。

2.输入数据的微小变化应该导致输出哈希值的**显著变化**。这意味着相似但不同的输入应该产生截然不同的哈希值，以提高安全性和减小冲突的可能性。

3.相同的输入应该始终产生相同的哈希值，以确保可重复性和一致性。

## PoH的工作流程

我们看一个简化版的 PoH 工作流程，从一个随机值开始，运行 hash 函数，并将输出（output）作为输入（input）再次运行该函数。记录函数执行的次数（index）以及每次调用的结果（output)。次数，提供了顺序和时间两个维度的支持；将输出作为输入，依次头尾相连，形成了一条完整的证据链。

随机值的选择，可以选择纽约时报当天的标题，或者其他的事实。

![image](./assets/9dd9018a-81d1-47f6-a6d6-2b2de34118f6.webp)

hashN 代表实际的 Hash 输出，Solana 中每个交易都与前一笔交易的哈希相连接，形成一个由交易构成的链，当一定数量的交易都被执行并构成了PoH 链后，它们被打包到一个区块（slot）中。![image](./assets/b7214250-75a6-4995-a1ca-a833a18a7cfd.webp)

只要选择的哈希函数是抗碰撞的，这个哈希集和就只能被单线程顺序计算出来。这满足了在 index 为 300 时，如果不通过算法实际运行 300 次，无法获得这样的结果的设定。

因此，我们可以从数据结构中推测出从 index 0 到 index 300 真实的过去的时间。这样以来，在网络中尽管每个节点的时间戳可能会有不一致，但是我们通过 hash 的次数（比如300），就变相的替代了时间，于是网络中有了全局一致的时间钟，并保持了交易的顺序。

## PoH的可验证性

由于PoH流是可验证有序的，在进行hash计算时我们会加入额外数据，如：Hash次数，事件信息等。因此，无论数据消息以多快的速度或多少被记录到基于PoH的数据结构中，我们都可以通过输入指定的次数和事件信息等来确定hash(区块)的先后顺序

## PoH的广播

当生成一个新区块时，我们可以将块的数据和结构进行切片并同时在多核GPU上并行运行验证，当验证完成后将会在Solana网络上进行广播。同时，由于区块的时序性，并且在各个节点中有一致的时间钟，我们很容易验证区块的有效性并且确定区块的先后顺序。

Solana 中事件的 Hash 次数可以用来表示时间的序列，从而形成网络中全局统一的时钟

# Solana Pos

## 引文

先来了解下在 Solana的系统架构中最重要的两种角色：**Leader**（出块者）和 **Validator**（验证者）。两者实际上都是质押了 SOL 代币的全节点，只是在不同的出块周期内，Leader 会由不同的全节点来充当，而没有当选 Leader 的全节点会成为 Validator。 所以在选择验证者方面， Solana 采用的是 PoS（权益证明）机制，验证者是通过抵押一定数量的代币来参与网络交易的验证的，持有更多代币的验证者有更大的机会被选中生成新的区块。

![image](./assets/632e813a-47c9-4daf-a0a9-c99894838b07.webp)

1.用户发起交易后，会被客户端直接转发给 Leader 节点，或者先被普通节点接收，再立刻转发给 Leader；

2.出块者 Leader 接收网络内全部的待处理交易，一边执行，一边给交易指令排序，制成交易序列（类似区块）。每隔一段时间，Leader 会把排好的交易序列发送给 Validator 验证节点；

3.Validator 按照交易序列（区块）给定的顺序执行交易，产生相应的状态信息State（执行交易会改变节点的状态，比如改变某些账户的余额）；

4.每发送 N 个交易序列，Leader 会定期公开本地的状态 State，Validator会将其与自己的 State 作对比，给出 肯定/否定 的投票。这一步就类似于以太坊2.0或其他POS公链里的“检查点”。

5.如果在规定时间内，Leader收集到占全网 2/3 质押权重的节点们给出的肯定票，则此前发布的交易序列和状态 State 就被敲定，“检查点”通过，相当于区块完成最终确认 Finality；

6.一般而言，给出肯定票的 Validator 节点与出块者 Leader 所执行的交易、执行后的状态都是相同的，数据会同步。

**Solana 如何通过 PoS 指定 Leader ？**

在 Solana 的共识协议中，有 Epoch（纪元）和Slot（间隔）两大时间单位。每个 Slot 约为0.4~0.8秒，相当于一个区块的时间间隔。而每个Epoch周期包含43.2万个Slot（区块），长达2~4天。每过4个 Slot（出块周期），Leader节点就会进行一次变更。

![image](./assets/40488b70-a5be-4875-aaa2-c40407ca57ca.webp)

在每个新的Epoch周期开始时，Solana网络会按照各节点的质押权重进行抽选，组成一个出块者Leader轮换名单，“钦定”了未来不同时刻的出块者。也就是说出块者会提前获知他们成为出块者。 具体而言，究竟如何指定 Leader 会考虑诸多因素，比如：

1.**质押的代币数量：** 在 PoS 中，质押的代币数量是一个关键的考虑因素。Validator 通常倾向于选择质押数量较大的节点，因为这增加了节点被选中为区块生产者的机会。这也有助于确保网络由具有足够利益参与的节点维护。

2.**节点的性能：** Validator 的节点性能是另一个关键因素。高性能的节点能够更快速地验证和打包交易，有助于维持网络的高吞吐量。Validator 可能会选择性能较好的节点以提高整个网络的效率。

3.**网络延迟：** Validator 可能会考虑节点之间的网络延迟。选择网络延迟较低的节点有助于减少区块的传播时间，从而提高网络的实时性。

4.**节点的可用性：** Validator 会关注节点的可用性，确保它们能够稳定运行而不容易出现故障。可靠的节点能够为网络提供更稳定的服务。

Solana 要实现的目标是选择一组合适的 Leader，确保网络的安全性、效率和公平性。通过综合考虑这些因素，Solana 能够做出最佳的区块生产决策，从而推动网络的正常运行。

### 回顾

现在在了解了基础的细节后，让我们来看看 Solana 的网络整体是如何通过 PoH 和 PoS 运作的：

1.**生成交易：** 用户创建并广播交易，包含交易的详细信息和数字签名。

2.**PoH 链上的排序：** 交易的哈希通过数字签名连接到 PoH 链上。由于 PoH 链是有序的，交易也就被排序了。

3.**Validator** **验证：** Validator 负责验证交易的有效性，并选择哪些交易将包含在下一个区块中。Validator 的选择可能基于质押的代币数量、验证者的性能等因素。

4.**交易打包成区块：** Validator 选择的交易被打包成一个区块，其中包括一个特殊的块生产交易，它包含了当前 PoH 链的哈希以及其他信息。

5.**区块传播和确认：** 区块广播到整个网络，其他节点验证并确认区块的有效性。确认后，区块和其中包含的交易就被添加到整个区块链中。

通过这个过程，Solana 通过 PoH 链的时间有序性和 PoS 的节点验证机制，实现了交易的流转和整个区块链的更新。这样的设计使得 Solana 平均出块时间被压缩至 400 毫秒，且无需 Layer2 即拥有较高速度，手续费亦可忽略不计。

Solana 通过 PoH 的机制保证了网络中事件的有序性，通过 PoS 的节点验证机制，为其网络提供了高性能和低延迟的特性。

# **Solana 账户**

## 引文

在了解完历史证明的概念之后之后让我们一起来学习 Solana 中最重要的概念之一 ：账户。账户之所以这么重要，是因为 Solana 作为一个分布式区块链系统，所有的信息都存储在账户中，如智能合约（Solana 叫 Onchain Program）、状态信息、Token数据、配置信息等都是存储在一个个账户中。

在学习 Solana 账户之前，让我们首先回顾一下以太坊的账户类型

以太坊将账户划分为两类：**外部账户（EOA）**和**合约账户（Contract Account）**。

## 外部账户

EOA-外部账户(external owned account)是由人们通过私钥创建的账户。 是真实世界的金融账户的映射，拥有该账户私钥的任何人都可以控制该账户。 如同银行卡，到ATM机取款时只需要密码输入正确即可交易。 这也是人类与以太坊账本沟通的唯一媒介，因为以太坊中的交易需要签名， 而只能使用拥有私有外部账户签名。大家通过 Metamask 创建的账户就属于外部账户。

外部账户特点总结：

1.拥有以太币余额。

2.能发送交易，包括转账和执行合约代码。

3.被私钥控制。

4.没有相关的可执行代码。

## 合约账户

含有合约代码的账户。 被外部账户或者合约创建，合约在创建时被自动分配到一个账户地址， 用于存储合约代码以及合约部署或执行过程中产生的存储数据。 合约账户地址是通过SHA3哈希算法产生，而非私钥。 因无私钥，因此无人可以拿合约账户当做外部账户使用。 只能通过外部账户来驱动合约执行合约代码。

让我们来理解一下外部账户和合约账户的异同

![image](./assets/fd74dbca-b8a9-4011-9395-66f553363d51.webp)

## Solana账户

在以太坊中，我们将代码与数据、状态直接存储在智能合约中。而 Solana 账户最大的不同就是将两者分开存放在不同的账户上。所以 Solana 账户又分为**程序账户**和**数据账户**。（*说明：Solana中的智能合约并不叫“智能合约”，而是“程序program”，尽管它们代表的是相似的概念。为了避免混淆，后续我们将统一使用“程序”这一术语。*）

●**程序账户（可执行账户）**：存储不可变的数据，主要用于存储程序的代码（BPF 字节码）。

●**数据账户（不可执行账户）**：存储可变的数据，主要用于存储程序的状态。

Solana 链上程序是只读或无状态的，即程序的账户（可执行账户）只存储代码，不存储任何状态，程序会把状态存储在其他独立的账户（不可执行账户）中。如果一个程序账户是一个数据账户的所有者，那么它就可以改变数据账户中的状态。

# Solana账户2

## 引文

Solana 的账户与租金

Solana 账户模型中还有一个特殊的「租金（Rent）」的概念。租金与交易费用不同。用户支付租金以将数据存储在 Solana 区块链上。而交易费用是为了处理网络上的指令而支付的。

与以太坊不同，Solana 会收取在其网络上的账户一笔用于存储数据状态的费用，即租金。如果账户无法支付租金，系统将删除这个账户，以减少为那些不再维护的数据花费存储成本。如果账户中的资产超过两年租金的最低余额，那么这个账户可以免交租金。Solana 上的租金存储费用为每字节 0.00000348 SOL/年，钱包数据大小为 372 字节，每个活跃钱包持有者必须保留 0.0026 SOL。

## **账户的分类**


用户账户：普通的钱包用户，类似于以太坊的 EOA 账户。

●程序账户：执行指定任务的账户，存储了程序的二进制文件，我们会在接下来的章节详细介绍。

●PDA(Program Derived Addresses)：程序派生地址。该类账户存储程序的状态，即程序执行过程中存储的数据，跟以太坊的状态是一个概念，只不过在这里被拆分到了单独的账户中。在下一节会进行专门的介绍。

●ATA(Associated Token Account)账户：关联账户。它是用户与特定的 SPL（Solana Program Library）Token 代币关联的账户，主要作用是允许用户方便管理他们持有的代币。

## 账户的定义

现在让我们通过一个账户的定义来回顾一下 Solana 账户的概念：

```javascript
pub struct Account {
2  /// 余额
3  pub lamports: u64,
4  /// 数据
5  pub data: Vec<u8>,
6  /// 所有者
7  pub owner: Pubkey,
8  /// 是否可执行账户
9  pub executable: bool,
10  /// 下次收租的时期
11  pub rent_epoch: Epoch,
12}
```

**
lamports**: 表示账户余额，lamport 是 Solana 中的基本货币单位，类似于以太坊的wei。

●**data**：表示存储的内容，这是一个字节数组，可以包含任意类型的数据，如程序的状态、用户资产信息，以及存储程序的字节码等。

●**owner**：表示拥有或管理该账户的程序的公钥。这表示了哪个程序有权对该账户进行操作。如果账户包含的数据是可执行的，那么owner表示加载该账户的程序。

●**executable**：表示是否可执行，如果为true，表示该账户中的数据可以被执行，是程序账户。如果为false，表示该账户用于存储普通的数据，而不是可执行代码。

●**rent_epoch**：表示下一次该账户将被扣除租金的时期。Solana使用租金机制来防止账户被无限期占用而不使用，避免状态膨胀。

# PDA是什么

## 引文

本节我们来学习一种特殊的账户—程序派生账户 PDA。

## 什么是PDA

在Solana区块链中，PDA指的是“程序派生地址”（Program Derived Address）。这是一种特殊类型的地址，由 Solana 的程序生成，而不是由用户的私钥直接派生。**PDA的主要目的是允许程序拥有和控制某些数据或资产，而不需要传统的私钥签名**。

读到这还一头雾水吗，没关系让我们把这个概念拆开做更详细的解释。

## 私钥、公钥与助记词

Solana 和以太坊一样，有私钥、公钥、助记词三种东西。私钥是私自保管不可示人的，当我们授权某一笔交易时，我们需要通过私钥签名并“授权”该交易。私钥是一串乱码，不好记，与之对应有一串助记词。助记词可以通过算法推出私钥，所以实际上我们在使用钱包时，只要记住助记词。而我们可以通过加密算法从私钥推算出公钥。公钥是可以展示给别人看的，别人通过你的公钥给你转账，同时公钥也是程序的地址，也叫 program_id。

要注意的是我们只能从助记词通过加密算法推算出私钥，从私钥推算出公钥，而无法反向从公钥推算出私钥，从私钥推算出助记词。否则我们所有加密地址中的代币都可以被任何人控制了。这其中的过程通过ECDSA算法进行计算，如果希望了解具体的原理可以先从了解 ECDSA算法开始。但是理解 PDA 账户可以不必这么深入，让我们先把这个过程进行一个简化。

![image](./assets/11c6df8f-f3f0-4c87-bbe5-6eb12b7f7031.webp)

如上图所示（这是一个简化的图示），每一个 X 轴私钥会在曲线上对应一个 Y轴公钥，**但是 Q 点的 公钥没有对应任何一个 X 轴上的私钥。那么这就意味着这个公钥没有对应的私钥！**这意味着这个公钥不是从私钥派生/衍生（Secret Key Derived）出来的。

这就是 PDA 的原理，“程序派生地址”（Program Derived Address）是没有对应的私钥的，它是由一个程序的program_id和seed派生/衍生出来的，这也是为什么它被称之为“程序派生地址”（Program Derived Address）。有时候我们通过 program_id 和 seed 获得的公钥正好有对应的私钥，那么这种情况下我们就需要重新生成一个公钥，通常是在我们的 program_id 和 seed 之外再加上一个数字（这个数字有个专有名词叫 bump），这个数字从 255 开始，依次往下，直到生成的公钥没有私钥为止。

## 那我们为什么需要PDA

在区块链中，你需要一个私钥来证明你拥有一个公钥的所有权，同时你才能签字同意这个账户的转账请求。但如果这个账户的所有者不是一个人而是一个去中心化程序，那么把私钥放在这个程序上就不是一个好主意，因为所有程序代码都在链上都是公开的，如果所有人都能看到你的私钥，那么人们就能进行一些恶意操作，比如偷走你的代币。这时我们就需要一个没有私钥的 PDA。 这样程序不需要私钥就能对一个地址进行签名操作。

## 如何生成PDA地址

这里我们使用 Solana 的Anchor开发框架，实现 PDA 账户的初始化（Anchor 框架我们会在后续章节专门介绍，这里只是让大家简单了解下 PDA 账户的生成过程）。

```javascript
// PDA 账户存储的数据
2pub struct Counter {
3    count: u64
4}
```

这个 PDA 账户存储的是Counter结构的数据，它包含了一个u64类型的count值。

```javascript
pub struct InitializeAccounts<'info> {
2		#[account(
3			init, 
4			seeds = [b"my_seed", 
5							 user.key.to_bytes().as_ref()
6							]
7			bump,
8			payer = user, 
9			space = 8 + 8
10		)]
11		pub pda_counter: Account<'info, Counter>,
12}
```

其中的pda_counter字段为要生成的PDA 账户，我们标记了初始化时用到的seeds值及bump，其中的 seeds 可以是根据业务场景设置的任意字节数组，Anchor 默认使用符合条件的第一个 bump 值，不需要我们手动指定，同时Anchor 内部也会自动获取program_id，同样不需要我们手动指定。

但是我们需要指定账户所占用的空间大小space以及支付初始化交易费的账户payer。这里指定账户的空间大小为16个字节，前 8 个字节存储 Anchor 自动添加的鉴别器，用于识别帐户类型。接下来的 8 个字节为存储在Counter帐户类型中的数据分配空间（count为 u64 类型，占用 8 字节），space 主要用于计算账户在网络中的租金。

以上就是生成 PDA 账户的部分代码示意，虽然并不完整，但向我们展示了 PDA 账户涉及到的相关内容：program_id 程序ID、seed 种子、bump 值、space 空间。后续章节会进行详细的介绍。