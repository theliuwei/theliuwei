<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Docker基础 | THELIUWEI</title>
    <meta name="description" content="THELIUWEI">
    <meta name="generator" content="VitePress v1.1.0">
    <link rel="preload stylesheet" href="/assets/style._5y_-cTi.css" as="style">
    
    <script type="module" src="/assets/app.vYpfGtnj.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/framework.DF40YQsC.js">
    <link rel="modulepreload" href="/assets/chunks/theme.FjXRaigR.js">
    <link rel="modulepreload" href="/assets/docker_基础知识.md.C61n08Iv.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8d7d19a><!--[--><!--]--><!--[--><span tabindex="-1" data-v-b0075c75></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-b0075c75> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8d7d19a data-v-6ee65aae><div class="VPNavBar has-sidebar top" data-v-6ee65aae data-v-ee4c453d><div class="wrapper" data-v-ee4c453d><div class="container" data-v-ee4c453d><div class="title" data-v-ee4c453d><div class="VPNavBarTitle has-sidebar" data-v-ee4c453d data-v-3f337961><a class="title" href="/" data-v-3f337961><!--[--><!--]--><!--[--><img class="VPImage logo" src="/Subtract.svg" alt data-v-83cdec58><!--]--><span data-v-3f337961>THELIUWEI</span><!--[--><!--]--></a></div></div><div class="content" data-v-ee4c453d><div class="content-body" data-v-ee4c453d><!--[--><!--]--><div class="VPNavBarSearch search" data-v-ee4c453d><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-ee4c453d data-v-adfd3cad><span id="main-nav-aria-label" class="visually-hidden" data-v-adfd3cad>Main Navigation</span><!--[--><!--[--><div class="VPFlyout VPNavBarMenuGroup active" data-v-adfd3cad data-v-92de6450><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-92de6450><span class="text" data-v-92de6450><!----><span data-v-92de6450>系统课程</span><span class="vpi-chevron-down text-icon" data-v-92de6450></span></span></button><div class="menu" data-v-92de6450><div class="VPMenu" data-v-92de6450 data-v-24c1871e><div class="items" data-v-24c1871e><!--[--><!--[--><div class="VPMenuGroup" data-v-24c1871e data-v-d3e0060d><p class="title" data-v-d3e0060d>系统课程</p><!--[--><!--[--><div class="VPMenuLink" data-v-d3e0060d data-v-6a4a37a0><a class="VPLink link" href="/%E6%9E%B6%E6%9E%84/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html" data-v-6a4a37a0><!--[-->Architecture<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-d3e0060d data-v-6a4a37a0><a class="VPLink link" href="/c++/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html" data-v-6a4a37a0><!--[-->C++<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-d3e0060d data-v-6a4a37a0><a class="VPLink link" href="/css/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html" data-v-6a4a37a0><!--[-->Css<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-d3e0060d data-v-6a4a37a0><a class="VPLink link active" href="/docker/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html" data-v-6a4a37a0><!--[-->Docker<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-d3e0060d data-v-6a4a37a0><a class="VPLink link" href="/go/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html" data-v-6a4a37a0><!--[-->Go<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-d3e0060d data-v-6a4a37a0><a class="VPLink link" href="/html/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html" data-v-6a4a37a0><!--[-->Html<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-d3e0060d data-v-6a4a37a0><a class="VPLink link" href="/mysql/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html" data-v-6a4a37a0><!--[-->MySQL<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-d3e0060d data-v-6a4a37a0><a class="VPLink link" href="/python/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html" data-v-6a4a37a0><!--[-->Python<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-d3e0060d data-v-6a4a37a0><a class="VPLink link" href="/react/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html" data-v-6a4a37a0><!--[-->React<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-d3e0060d data-v-6a4a37a0><a class="VPLink link" href="/vim/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html" data-v-6a4a37a0><!--[-->Vim<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-d3e0060d data-v-6a4a37a0><a class="VPLink link" href="/vite/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html" data-v-6a4a37a0><!--[-->Vite<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-d3e0060d data-v-6a4a37a0><a class="VPLink link" href="/vscode/%E7%BB%88%E7%AB%AF%E6%89%93%E5%BC%80vscode.html" data-v-6a4a37a0><!--[-->Vscode<!--]--></a></div><!--]--><!--]--></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-ee4c453d data-v-3e09bfba><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-3e09bfba data-v-7098ddd8 data-v-6196e9b8><span class="check" data-v-6196e9b8><span class="icon" data-v-6196e9b8><!--[--><span class="vpi-sun sun" data-v-7098ddd8></span><span class="vpi-moon moon" data-v-7098ddd8></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-ee4c453d data-v-70d7bd23 data-v-af1be97c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/pythonliuwei-root" aria-label="github" target="_blank" rel="noopener" data-v-af1be97c data-v-3b11187b><span class="vpi-social-github" /></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-ee4c453d data-v-902e385e data-v-92de6450><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-92de6450><span class="vpi-more-horizontal icon" data-v-92de6450></span></button><div class="menu" data-v-92de6450><div class="VPMenu" data-v-92de6450 data-v-24c1871e><!----><!--[--><!--[--><!----><div class="group" data-v-902e385e><div class="item appearance" data-v-902e385e><p class="label" data-v-902e385e>Appearance</p><div class="appearance-action" data-v-902e385e><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-902e385e data-v-7098ddd8 data-v-6196e9b8><span class="check" data-v-6196e9b8><span class="icon" data-v-6196e9b8><!--[--><span class="vpi-sun sun" data-v-7098ddd8></span><span class="vpi-moon moon" data-v-7098ddd8></span><!--]--></span></span></button></div></div></div><div class="group" data-v-902e385e><div class="item social-links" data-v-902e385e><div class="VPSocialLinks social-links-list" data-v-902e385e data-v-af1be97c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/pythonliuwei-root" aria-label="github" target="_blank" rel="noopener" data-v-af1be97c data-v-3b11187b><span class="vpi-social-github" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-ee4c453d data-v-13adacfc><span class="container" data-v-13adacfc><span class="top" data-v-13adacfc></span><span class="middle" data-v-13adacfc></span><span class="bottom" data-v-13adacfc></span></span></button></div></div></div></div><div class="divider" data-v-ee4c453d><div class="divider-line" data-v-ee4c453d></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8d7d19a data-v-2c047c88><div class="container" data-v-2c047c88><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2c047c88><span class="vpi-align-left menu-icon" data-v-2c047c88></span><span class="menu-text" data-v-2c047c88>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2c047c88 data-v-c9d717c9><button data-v-c9d717c9>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-d8d7d19a data-v-fee4374d><div class="curtain" data-v-fee4374d></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-fee4374d><span class="visually-hidden" id="sidebar-aria-label" data-v-fee4374d> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="group" data-v-fee4374d><section class="VPSidebarItem level-0 has-active" data-v-fee4374d data-v-f97dc0b5><div class="item" role="button" tabindex="0" data-v-f97dc0b5><div class="indicator" data-v-f97dc0b5></div><h2 class="text" data-v-f97dc0b5>docker</h2><!----></div><div class="items" data-v-f97dc0b5><!--[--><div class="VPSidebarItem level-1 is-link" data-v-f97dc0b5 data-v-f97dc0b5><div class="item" data-v-f97dc0b5><div class="indicator" data-v-f97dc0b5></div><a class="VPLink link link" href="/docker/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html" data-v-f97dc0b5><!--[--><p class="text" data-v-f97dc0b5>基础知识</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-f97dc0b5 data-v-f97dc0b5><div class="item" data-v-f97dc0b5><div class="indicator" data-v-f97dc0b5></div><a class="VPLink link link" href="/docker/%E5%9C%A8linux%E7%B3%BB%E7%BB%9F%E5%BB%BA%E7%AB%8Bdocker%E5%AE%B9%E5%99%A8.html" data-v-f97dc0b5><!--[--><p class="text" data-v-f97dc0b5>在linux系统中建立docker容器</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8d7d19a data-v-7a280cb5><div class="VPDoc has-sidebar has-aside" data-v-7a280cb5 data-v-ef13635e><!--[--><!--]--><div class="container" data-v-ef13635e><div class="aside" data-v-ef13635e><div class="aside-curtain" data-v-ef13635e></div><div class="aside-container" data-v-ef13635e><div class="aside-content" data-v-ef13635e><div class="VPDocAside" data-v-ef13635e data-v-c7df15b5><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" role="navigation" data-v-c7df15b5 data-v-b96b0a5f><div class="content" data-v-b96b0a5f><div class="outline-marker" data-v-b96b0a5f></div><div class="outline-title" role="heading" aria-level="2" data-v-b96b0a5f>On this page</div><nav aria-labelledby="doc-outline-aria-label" data-v-b96b0a5f><span class="visually-hidden" id="doc-outline-aria-label" data-v-b96b0a5f> Table of Contents for current page </span><ul class="VPDocOutlineItem root" data-v-b96b0a5f data-v-3d7578de><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-c7df15b5></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-ef13635e><div class="content-container" data-v-ef13635e><!--[--><!--]--><main class="main" data-v-ef13635e><div style="position:relative;" class="vp-doc _docker_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86" data-v-ef13635e><div><h1 id="docker基础" tabindex="-1">Docker基础 <a class="header-anchor" href="#docker基础" aria-label="Permalink to &quot;Docker基础&quot;">​</a></h1><blockquote><p>官方文档地址：<a href="https://www.docker.com/get-started" target="_blank" rel="noreferrer">https://www.docker.com/get-started</a> 推荐</p><p>中文参考手册：https://docker_practice.gitee.io/zh-cn/中文gitee</p></blockquote><h2 id="什么是docker" tabindex="-1"><strong>什么是Docker</strong> <a class="header-anchor" href="#什么是docker" aria-label="Permalink to &quot;**什么是Docker**&quot;">​</a></h2><h3 id="_1-官网定义" tabindex="-1"><strong>1.官网定义：</strong> <a class="header-anchor" href="#_1-官网定义" aria-label="Permalink to &quot;**1.官网定义：**&quot;">​</a></h3><p>我们帮助开发人员和开发团队构建和发布应用</p><p>我们为你提供一个完整的容器解决方案，不管你是谁，不管你在哪里，你都可以开始容器的旅程</p><p>docker是一个容器技术，docker引擎容器（container）软件（redis mysql tomcat rabbitmq） 构建发布应用</p><p>通俗理解为docker是一个软件容器平台|引擎|技术|</p><h3 id="早期docker定义-运行你的应用不需要你的环境" tabindex="-1"><strong>早期docker定义：运行你的应用不需要你的环境</strong> <a class="header-anchor" href="#早期docker定义-运行你的应用不需要你的环境" aria-label="Permalink to &quot;**早期docker定义：运行你的应用不需要你的环境**&quot;">​</a></h3><blockquote><p>容器到底装的是什么？</p><p>容器装的就是一个个的软件服务</p></blockquote><h2 id="docker优势" tabindex="-1"><strong>Docker优势</strong> <a class="header-anchor" href="#docker优势" aria-label="Permalink to &quot;**Docker优势**&quot;">​</a></h2><ul><li><p>环境一致，高效迁移</p><p>如：我们一个web应用程序涉及很多东西，比如django、mysql、redis、nginx等软件环境，当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来的情况，Docker则将程序以及使用软件环境直接绑定在一起，无论在哪个机器上保证的环境的一致。</p></li><li><p>进程级隔离，容器独立</p></li></ul><p>如：服务器自己的程序挂了，结果发现是别人程序错误把内存吃完了，自己程序因为内存不够就挂掉了，这种也是很常见的情况，如果你的程序的重要性不是非常高的话，公司基本上不可能让你的程序独享一台服务器，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免就会受到其他程序的干扰，导致自己的程序出现问题。Docker就能很好的解决环境隔离的问题，别人程序不会影响到自己的程序。</p><ul><li><p>镜像机制，便于部署</p><p>公司要弄一个活动，可能会有大量的流量进来，公司需要多部署几十台的服务器，在没有docker的情况下，要在几天内部署几十台服务器，这对运维人员来说非常的折磨，而且每台服务器的环境还不一定一样，就会出现各种问题，用Docker的话，我们只要将程序打包到镜像，你要多少台服务，我就给跑多少个容器，极大地提高了部署效率。</p></li></ul><h2 id="docker和虚拟机的区别" tabindex="-1"><strong>Docker和虚拟机的区别</strong> <a class="header-anchor" href="#docker和虚拟机的区别" aria-label="Permalink to &quot;**Docker和虚拟机的区别**&quot;">​</a></h2><blockquote><p>每一个容器是操作系统之间的隔离</p></blockquote><h2 id="docker-引擎的安装" tabindex="-1"><strong>Docker 引擎的安装</strong> <a class="header-anchor" href="#docker-引擎的安装" aria-label="Permalink to &quot;**Docker 引擎的安装**&quot;">​</a></h2><ol><li><p><strong>安装docker引擎</strong></p><p>linux发行版本 centos7+</p></li><li><p><strong>安装步骤</strong></p><p>官网安装步骤：<a href="https://docs.docker.com/engine/install/centos/" target="_blank" rel="noreferrer">https://docs.docker.com/engine/install/centos/</a></p><p>通用方式安装：跟linux的发行版本无关</p></li></ol><h3 id="linux平台下docker的通用方式安装方法" tabindex="-1"><strong>Linux平台下Docker的通用方式安装方法</strong> <a class="header-anchor" href="#linux平台下docker的通用方式安装方法" aria-label="Permalink to &quot;**Linux平台下Docker的通用方式安装方法**&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ curl -fsSL get.docker.com -o get-docker.sh # 执行下载docker引擎的脚本文件</span></span>
<span class="line"><span>$ sudo sh get-docker.sh --mirror Aliyun # 执行脚本通过脚本下载，设置阿里云镜像下载加速</span></span></code></pre></div><p>启动docker</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ sudo systemctl enable docker # 将docker加入开机自启动列表</span></span>
<span class="line"><span>$ sudo systemctl start docker # 启动docker服务(restart重启 status状态 stop停止)</span></span></code></pre></div><p>创建docker用户组</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ sudo groupadd docker</span></span></code></pre></div><p>将当前用户加入到docker组</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ sudo usermod -aG docker $USER # 修改过程中会自动创建docker</span></span></code></pre></div><p>测试docker安装是否正确</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker run hello-world</span></span></code></pre></div><p>查看docker引擎</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker info # 查看docker信息</span></span>
<span class="line"><span>$ docker version # 查看docker版本</span></span></code></pre></div><h3 id="docker中的核心概念" tabindex="-1"><strong>Docker中的核心概念</strong> <a class="header-anchor" href="#docker中的核心概念" aria-label="Permalink to &quot;**Docker中的核心概念**&quot;">​</a></h3><ol><li><p>镜像（image）</p><blockquote><p>定义：一个镜像代表一个软件</p></blockquote></li><li><p>容器 (container)</p><blockquote><p>定义：一个镜像运行一次就会生成一个容器，容器就是一个运行的件服务</p></blockquote></li><li><p>仓库（Respostory）</p><blockquote><p>定义： 仓库用来存储所有软件的镜像位置 =====&gt;仓库web界面 docker hub 中心仓库</p></blockquote></li><li><p>本地仓库</p><blockquote><p>定义：用于存储在使用docker过程中的相关镜像</p></blockquote></li></ol><h3 id="docker中核心架构图" tabindex="-1"><strong>Docker中核心架构图</strong> <a class="header-anchor" href="#docker中核心架构图" aria-label="Permalink to &quot;**Docker中核心架构图**&quot;">​</a></h3><ul><li><code>镜像</code>：一个镜像代表一个应用环境，它是一个只读的文件，如：mysql镜像，tomcat镜像，redis镜像，nginx镜像等。</li><li><code>容器</code>：镜像每次运行之后就是产生一个容器，就是正在运行的镜像，特点是可读可写。</li><li><code>仓库</code>：用来存放镜像的位置，类似与maven仓库，也是镜像下载和上传的位置。</li><li><code>dockFile</code>：docker生成镜像配置文件，用来书写自定义镜像的一些配置</li><li><code>tar</code>：一个镜像打包的文件，日后可以还原成镜像</li></ul><h3 id="镜像加速" tabindex="-1"><strong>镜像加速</strong> <a class="header-anchor" href="#镜像加速" aria-label="Permalink to &quot;**镜像加速**&quot;">​</a></h3><h3 id="docker运行流程" tabindex="-1"><strong>docker运行流程</strong> <a class="header-anchor" href="#docker运行流程" aria-label="Permalink to &quot;**docker运行流程**&quot;">​</a></h3><p>如何拉取官方镜像</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker pull tomcat  # 拉取最新版本的tomcat</span></span>
<span class="line"><span>$ docker pull tomcat:8.0 # 拉取指定版本的tomcat</span></span></code></pre></div><h3 id="docker如何配置阿里云的镜像加速" tabindex="-1"><strong>Docker如何配置阿里云的镜像加速</strong> <a class="header-anchor" href="#docker如何配置阿里云的镜像加速" aria-label="Permalink to &quot;**Docker如何配置阿里云的镜像加速**&quot;">​</a></h3><ol><li>进入阿里云的官方网站</li><li>使用账号名和密码进行登录或者扫码登录</li><li>在控制台搜索镜像加速服务</li></ol><ul><li><p>访问阿里云登录自己账号查看docker镜像加速服务</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ sudo mkdir -p /etc/docker</span></span>
<span class="line"><span>$ sudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  &quot;registry-mirrors&quot;: [&quot;&lt;https://xnan2sz4.mirror.aliyuncs.com&gt;&quot;]</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>EOF</span></span>
<span class="line"><span>$ sudo systemctl daemon-reload</span></span>
<span class="line"><span>$ sudo systemctl restart docker</span></span></code></pre></div></li><li><p>验证docker的镜像加速是否生效</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker info</span></span>
<span class="line"><span>    ...........</span></span>
<span class="line"><span>    127.0.0.0/8</span></span>
<span class="line"><span>    Registry Mirrors:</span></span>
<span class="line"><span>    &#39;&lt;https://lz2nib3q.mirror&gt;,aliyuncs.com&#39;</span></span>
<span class="line"><span>    Live Restore Enabled: false</span></span>
<span class="line"><span>    Product License: Commounity Engine</span></span></code></pre></div></li></ul><h3 id="概念" tabindex="-1"><strong>概念</strong> <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;**概念**&quot;">​</a></h3><ol><li>docker中的三个概念 <ol><li>仓库 <ol><li>远程仓库：docker公司在世界范围内维护的一个中心，用来集中管理docker中的镜像-----&gt;搜索仓库 docker hub</li><li>本地仓库：用来存储自己使用过的镜像，在中心仓库下载镜像存储到本地仓库 /var/lib/docker</li></ol></li><li>镜像 image <ol><li>镜像是只读的，不能进行写操作</li></ol></li><li>容器 container <ol><li>容器可读可写</li></ol></li></ol></li></ol><h3 id="docker第一个应用程序" tabindex="-1"><strong>docker第一个应用程序</strong> <a class="header-anchor" href="#docker第一个应用程序" aria-label="Permalink to &quot;**docker第一个应用程序**&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span># hello-world</span></span>
<span class="line"><span>$ docker run hello-world</span></span></code></pre></div><p>通过docker第一个程序总结docker执行流程</p><p><code>docker run</code>执行镜像 首先去本地仓库去查找，如果本地仓库有，自动对镜像生成一个容器，如果本地仓库没有，它会去中心仓库去下载到本地仓库，然后对镜像生成一个容器。</p><h3 id="docker中镜像的相关操作" tabindex="-1"><strong>docker中镜像的相关操作</strong> <a class="header-anchor" href="#docker中镜像的相关操作" aria-label="Permalink to &quot;**docker中镜像的相关操作**&quot;">​</a></h3><blockquote><p>辅助命令：docker version</p><p>功能：用来查看docker客户端引擎和server端引擎版本信息</p><p>辅助命令：<code>docker info</code></p><p>功能：用来查看docker引擎</p><p>辅助命令：<code>docker --help</code></p><p>功能：帮助信息</p></blockquote><ol><li><p>镜像 image</p><p>查看当前本地仓库存在哪些镜像</p><p><code>docker image ls</code> 或者 <code>docker images</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker images</span></span>
<span class="line"><span># 结果解释</span></span>
<span class="line"><span>`REPOSITORY` 镜像名称</span></span>
<span class="line"><span>`TAG` 镜像版本</span></span>
<span class="line"><span>`IMAGE ID` 镜像ID</span></span>
<span class="line"><span>`CREATED ` 镜像创建时间</span></span>
<span class="line"><span>`SIZE` 镜像大小</span></span>
<span class="line"><span>REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span></span>
<span class="line"><span>hello-world   latest    feb5d9fea6a5   10 months ago   13.3kB</span></span>
<span class="line"><span>tomcat        8.0       ef6a7c98d192   3 years ago     356MB</span></span></code></pre></div><p>注意：以后在使用镜像时，可以使用镜像的ID短名去使用</p></li><li><p>查看当前本地仓库指定的镜像有哪些版本</p><p><code>docker images 镜像名</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker images tomcat</span></span></code></pre></div></li><li><p>展示出所有的docker镜像</p><p><code>docker images -a</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker images -a</span></span></code></pre></div></li><li><p>展示出所有docker镜像的ID</p><p><code>docker images -q</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker images -q</span></span>
<span class="line"><span># 展示内容为镜像的ID</span></span>
<span class="line"><span>feb5d9fea6a5</span></span>
<span class="line"><span>ef6a7c98d192</span></span></code></pre></div></li><li><p>下载一个镜像</p><p><code>docker pull</code> 镜像名称 或者<code>docker pull</code> 镜像名称:版本</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker pull tomcat # 获取最新版本</span></span>
<span class="line"><span>$ docker pull tomcat:9.0 # 获取指定版本</span></span></code></pre></div></li><li><p>搜索镜像</p><p><code>docker search</code> 镜像名称</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker search tomcat # 智能查看当前镜像是否存在，不能列出版本</span></span></code></pre></div></li><li><p>删除镜像</p><p><code>docker image rm</code> 镜像名称(name:tag)或者<code>docker image rm</code>镜像ID</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span># 正常删除</span></span>
<span class="line"><span>$ docker image rmi tomcat:9.0</span></span>
<span class="line"><span>$ docker image rmi ef6a7c98d192</span></span>
<span class="line"><span># 强制删除</span></span>
<span class="line"><span>$ docker image rmi -f tomcat:9.0</span></span>
<span class="line"><span>$ docker image rmi -f ef6a7c98d192</span></span>
<span class="line"><span># 删除指定镜像名称的所有镜像----&gt;批量删除</span></span>
<span class="line"><span>$ docker image rmi -f $(docker images tomcat -q)</span></span>
<span class="line"><span># 删除仓库内的所有镜像</span></span>
<span class="line"><span>$ docker image rmi -rf $(docker images -q)</span></span></code></pre></div></li><li><p>清理镜像</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker image prune</span></span></code></pre></div><p>支持的子命令</p><ul><li>a 删除所有没有用的镜像，而不仅仅是临时文件。</li><li>f 强制删除镜像文件，无需弹出提示确认。</li></ul></li></ol><h3 id="docker中容器的基本操作1" tabindex="-1"><strong>docker中容器的基本操作1</strong> <a class="header-anchor" href="#docker中容器的基本操作1" aria-label="Permalink to &quot;**docker中容器的基本操作1**&quot;">​</a></h3><blockquote><p>操作容器的命令格式: docker 命令 [选项]</p></blockquote><ol><li><p>如何查看docker引擎中运行的容器有哪些？</p><p><code>docker ps</code> 查看当前docker引擎中正在运行的容器</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker ps</span></span>
<span class="line"><span># 结果解释</span></span>
<span class="line"><span>`CONTAINER ID` 容器ID</span></span>
<span class="line"><span>`IMAGE` 基于哪个镜像</span></span>
<span class="line"><span>` COMMAND` 容器内启动服务的命令</span></span>
<span class="line"><span>`CREATED` 容器创建时间</span></span>
<span class="line"><span>`STATUS` 容器状态</span></span>
<span class="line"><span>`PORTS` 容器服务监听端口</span></span>
<span class="line"><span>`NAMES` 容器名称</span></span>
<span class="line"><span>CONTAINER ID   IMAGE        COMMAND             CREATED          STATUS          PORTS      NAMES</span></span>
<span class="line"><span>6f755ceba23c   tomcat:8.0   &quot;catalina.sh run&quot;   23 seconds ago   Up 22 seconds   8080/tcp   infallible_fermat</span></span></code></pre></div><ol><li><p>查看所有容器（运行 停止）</p><p><code>docker ps -a</code></p></li><li><p>查看所有的容器id</p><p><code>docker ps -aq</code></p></li></ol></li><li><p>如何运行一个容器</p><p><code>docker run 镜像名</code> 或者 <code>docker run 镜像ID</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker run tomcat:8.0</span></span></code></pre></div><ol><li><p>简单运行tomcat镜像</p><p><code>docker run tomcat:8.0|(imageid)</code></p></li><li><p>运行tomcat容器，同时设置容器与宿主机端口的映射关系 <code>P</code></p><p><code>docker run -p 8080(宿主机):8080 tomcat:8.0</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker run -p 8080:8080 tomcat:8.0</span></span></code></pre></div><p>注意：可以映射多个端口</p></li><li><p>运行tomcat，开发端口映射，后台启动该服务 <code>d</code></p><p><code>docker run -p 8082:8080 -d tomcat:8.0</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker run -p 8082:8080 -d tomcat:8.0</span></span></code></pre></div></li><li><p>运行tomcat，开放端口映射，后台启动该服务，指定容器名称 <code>-name</code> 容器名称</p><p><code>docker run -d -p 8083:8080 --name tomcat01 tomcat:8.0</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker run -d -p 8083:8080 --name tomcat01 tomcat:8.0</span></span></code></pre></div></li></ol></li><li><p>停止 重启 暂停 恢复容器</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span># 停止</span></span>
<span class="line"><span>$ docker stop 容器id|容器名称</span></span>
<span class="line"><span>#重启</span></span>
<span class="line"><span>$ docker restart 容器id|容器名称</span></span>
<span class="line"><span>#启动</span></span>
<span class="line"><span>$ docker start 容器id|容器名称</span></span>
<span class="line"><span>#暂停</span></span>
<span class="line"><span>$ docker pause 容器id|容器名称</span></span>
<span class="line"><span>#恢复</span></span>
<span class="line"><span>$ docker unpause 容器id|容器名称</span></span></code></pre></div></li></ol><h3 id="docker中容器的基本操作2" tabindex="-1"><strong>docker中容器的基本操作2</strong> <a class="header-anchor" href="#docker中容器的基本操作2" aria-label="Permalink to &quot;**docker中容器的基本操作2**&quot;">​</a></h3><p>杀死容器</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>docker kill id|name</span></span>
<span class="line"><span>$ docker kill id</span></span></code></pre></div><p>删除容器</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>docker rm id|name</span></span>
<span class="line"><span>$ docker rm id</span></span></code></pre></div><p>删除一个正在运行的容器</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>docker rm -f id|name</span></span>
<span class="line"><span>$docker rm -f id</span></span></code></pre></div><p>查看容器内部的日志</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>docker logs id|name</span></span>
<span class="line"><span>$docker logs id</span></span>
<span class="line"><span>-t 加入时间戳</span></span>
<span class="line"><span>-f 跟随最新的日志打印  实时监控容器内服务的日志</span></span>
<span class="line"><span>--tail 数字显示最后多少条</span></span></code></pre></div><p>进入容器的内部</p><blockquote><p>容器内部其实是一个linux系统装上了相关的服务</p><p>进入容器内部相当于进入了一个新的linux系统里</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>docker exec -it id|name bash</span></span>
<span class="line"><span># -it 表示交互模式</span></span>
<span class="line"><span># 先查看一下运行的容器</span></span>
<span class="line"><span>$ docker ps</span></span>
<span class="line"><span>CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                                       NAMES</span></span>
<span class="line"><span>aaece9d9ef78   redis     &quot;docker-entrypoint.s…&quot;   7 minutes ago   Up 7 minutes   0.0.0.0:6379-&gt;6379/tcp, :::6379-&gt;6379/tcp   romantic_jepsen</span></span>
<span class="line"><span></span></span>
<span class="line"><span>$ docker exec -it aa bash # 这里的aa指的是aaece9d9ef78  可以缩写为aa</span></span></code></pre></div><p>退出容器</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>exit</span></span>
<span class="line"><span>$ exit</span></span></code></pre></div><h3 id="容器与宿主机之间的文件拷贝" tabindex="-1"><strong>容器与宿主机之间的文件拷贝</strong> <a class="header-anchor" href="#容器与宿主机之间的文件拷贝" aria-label="Permalink to &quot;**容器与宿主机之间的文件拷贝**&quot;">​</a></h3><ul><li><p>如何将容器中指定文件和目录拷贝到宿主机</p><p><code>docker cp 容器id|name:容器中文件或目录 主机目录</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker cp id:/home/index.html /root</span></span>
<span class="line"><span>$ docker cp id:/usr/home/tt /root</span></span></code></pre></div></li><li><p>如何将主机中指定文件和目录拷贝到容器内</p><p><code>docker cp 主机文件和目录 容器id:容器中目录</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker cp /root/index.html id:/home/</span></span></code></pre></div></li></ul><h3 id="部署项目到docker容器内" tabindex="-1"><strong>部署项目到docker容器内</strong> <a class="header-anchor" href="#部署项目到docker容器内" aria-label="Permalink to &quot;**部署项目到docker容器内**&quot;">​</a></h3><blockquote><ol><li>将项目上传到linux服务器2. 通过<code>docker cp</code>命令将项目复制到tomcat的webapps目录中即可3. 使用ip+端口进行测试访问</li></ol></blockquote><ol><li><code>docker cp /root/test.war id:/usr/lcoal/tomcat/webapp</code></li></ol><h3 id="docker中容器的基本操作3" tabindex="-1"><strong>docker中容器的基本操作3</strong> <a class="header-anchor" href="#docker中容器的基本操作3" aria-label="Permalink to &quot;**docker中容器的基本操作3**&quot;">​</a></h3><ol><li><p>查看容器内运行进程的指令</p><p>docker top 容器id或者 docker top 容器name</p><p><code>docker top id|name</code></p></li><li><p>查看容器内细节指令</p><p>docker inspect 容器id或者docker inspect 容器name</p><p><code>docker inspect id|name</code></p></li><li><p>容器数据卷机制【重点】</p><ol><li><p>数据卷 Data Volume</p><blockquote><p>作用：用来实现容器中的数据与宿主机中数据进行映射的（同步）</p><p><code>注意</code>：数据卷使用时必须在容器首次启动时设置</p><p>使用： <code>docker run -v 宿主机目录:容器内目录</code></p><p><code>数据卷的真正意义</code>：在以后使用数据库搭建在容器中的时候，数据库用于存储，如果不使用数据卷的方式，会导致人员把搭建的mysql数据库的容器给删除了，就会导致<code>数据丢失</code></p><p>使用数据卷将容器内数据映射到本地，把容器删除了也不会影响本机与数据卷同步的数据</p></blockquote></li><li><p>创建方式一：使用绝对路径设置数据卷</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker run -v 宿主机绝对路径:容器内路径:(ro)</span></span>
<span class="line"><span># 注意：这种方式会将容器路径的原始内容全部清空，始终以宿主机路径为主</span></span>
<span class="line"><span># ro: ready only 如果在设置数据卷时指定ro，代表以后容器内的路径是只读的</span></span>
<span class="line"><span>$ docker run -d -p 8081:8080 --name tomcat01 -v /root/apps:/usr/local/tomcat/webapps</span></span></code></pre></div></li><li><p>创建方式二：使用别名方式设置数据卷</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker run -v aa:/usr/local/tomcat/webapps ......</span></span>
<span class="line"><span># aa 代表docker数据卷中别名，注意：这个别名如果存在docker直接使用 aa不存在直接创建</span></span>
<span class="line"><span># 使用别名方式保留容器路径内原始内容，前提别名对应不能存在内容</span></span>
<span class="line"><span># 注意：docker根据别名创建目录默认在:/var/lib/docker/volumes/</span></span></code></pre></div></li></ol></li></ol><h3 id="docker中容器的基本操作4" tabindex="-1"><strong>docker中容器的基本操作4</strong> <a class="header-anchor" href="#docker中容器的基本操作4" aria-label="Permalink to &quot;**docker中容器的基本操作4**&quot;">​</a></h3><ol><li><p>docker三个核心概念</p><ol><li><p>仓库 repostory</p><p>作用：docker 官方维护一个仓库，用来集中存储镜像</p></li><li><p>镜像 Image</p><p>作用：一个镜像代表一个软件服务</p><p>特点：只读</p></li><li><p>容器 container</p><p>作用：镜像没运行一次形成一个容器，运行的容器代表一个正在运行的软件服务</p><p>特点：可读可写</p></li></ol></li><li><p>将容器打包成一个新的镜像</p><blockquote><p>为什么要将容器打包程一个新的镜像？</p><p>原因：容器可读可写，基于这个特性我们可以对容器进行我们自己的深度定制</p><p>我们可以将修改的容器打包成一个新的镜像，以后基于这个镜像运行成容器存在原始定制特性</p><p>目的：可以将项目都放到原始容器后，在进行打包成新的容器，以后可放在多个新的服务器上，做到分布式部署</p></blockquote></li><li><p>如何将容器打包成一个新的镜像</p><p><code>docker commit -m &quot;描述信息&quot; 容器id 镜像名:版本</code>或者<code>docker commit -m &quot;描述信息&quot; 容器名称 镜像名:版本</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker commit -m &quot;描述信息&quot; id 镜像名称:版本</span></span></code></pre></div></li><li><p>镜像的备份和恢复</p><p><strong>备份镜像</strong></p><p><code>docker save 镜像名:版本 -o 镜像原始名称-版本.tar</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker save tomcat:8.0 -o tomcat-8.0.tar    # 默认备份到当前目录</span></span></code></pre></div><p><strong>恢复镜像</strong></p><p><code>docker load -i 镜像原始名称-版本.tar</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker load -i tomcat-8.0.tar</span></span></code></pre></div></li></ol><h3 id="docker中镜像原理" tabindex="-1"><strong>docker中镜像原理</strong> <a class="header-anchor" href="#docker中镜像原理" aria-label="Permalink to &quot;**docker中镜像原理**&quot;">​</a></h3><ol><li><p>镜像为什么这么大？</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>原始 tomcat:10M</span></span>
<span class="line"><span>镜像 tomcat:356M</span></span></code></pre></div><p>解释：容器独立操作系统（精简的linux操作系统+软件服务）====&gt;镜像运行====&gt;镜像（操作系统+软件服务）</p><blockquote><p>镜像是一种轻量级的，可独立执行的软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需要的全部内容，包括代码，运行时所需要的库、环境变量和配置文件。</p></blockquote></li><li><p>UniFS 联合文件系统 叠加文件系统</p><blockquote><p>Union文件系统是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改为一次提交来一层一层的叠加，同时可以将不同目录挂在到同一个虚拟文件系统下。</p><p>Union文件系统是docker镜像的基础，这种文件系统特性就是一次同时加载多个文件系统，但从外面看起来只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p></blockquote></li><li><p>原理</p><blockquote><p>docker中的镜像实际是由一层一层文件系统组成的，UnionFS联合文件系统</p><p><code>bootloader</code> 引用加载器</p><p><code>kwenel</code>内核</p></blockquote><ul><li>bootfs（bot file system）主要包含<code>bootloader</code>和<code>kernel</code> ,bootloader主要引导加载kernel，linux刚启动时会加载bootfs文件系统，在docker镜像的最底层就是botfs。这一层与<code>Linux/Unix系统是一样的</code>，包括boot加载器（bootloader）和内核(kernel)。当boot加载完成之后，整个内核都在内存中，此时内存的使用权已经由bootfs交给内核，此时会卸载bootfs。</li><li>rootfs（root file system）在bootfs之上，包含的就是典型的linux系统的<code>/dev</code> <code>/proc</code> <code>/bin</code> <code>/etc</code> 等标准目录和文件。rootfs就是各种功能不同操作系统的发行版本，比如<code>ubuntu、centos</code></li><li>我们平时安装进虚拟机的centos都有几个GB,为什么docker这里才只有200MB？对于一个精简的os，rootfs可以很小，只需要包括最基本的命令，工具和程序库就可以了。因为底层直接使用<code>Host的Kernal</code>,自己只需要提供<code>rootfs</code>就行了，由此可见不同的linux发行版，他们的bootfs一致，rootfs有区别。因此不通的发行版可以共用<code>bootfs</code>。</li></ul></li></ol><h3 id="为什么docker镜像要使用这种分层结构" tabindex="-1"><strong>为什么docker镜像要使用这种分层结构？</strong> <a class="header-anchor" href="#为什么docker镜像要使用这种分层结构" aria-label="Permalink to &quot;**为什么docker镜像要使用这种分层结构？**&quot;">​</a></h3><blockquote><p>好处：资源共享</p></blockquote><ul><li>有多个镜像都是从相同的base镜像构建而来的，那么宿主机只需要在磁盘中保存一份base镜像。同时内存中也主需要加载一份base镜像，就可以为所有容器服务了，而且镜像的每一层都可以被共享。docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部，这一层被称为容器层，容器层之下都叫镜像层。</li></ul><h3 id="docker-安装mysql服务" tabindex="-1"><strong>docker 安装mysql服务</strong> <a class="header-anchor" href="#docker-安装mysql服务" aria-label="Permalink to &quot;**docker 安装mysql服务**&quot;">​</a></h3><blockquote><p>建议：使用任何容器参考dockerhub官方网站+搜索引擎(百度google)</p></blockquote><ol><li><p>下载mysql镜像</p><ol><li>访问docker hub 官方网站搜索mysql</li><li>确定版本 5.x (行业流行版本) 8.x（最新版本，引擎更快 特性）</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span># registry.hub.docker.com</span></span>
<span class="line"><span>$ docker pull mysql:5.6</span></span></code></pre></div></li><li><p>运行mysql</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span># 启动mysql 开放端口映射(3306) 指定root用户密码 -e代表环境</span></span>
<span class="line"><span># 如果本机有mysql不能使用3306端口进行端口映射</span></span>
<span class="line"><span>$ docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span></span>
<span class="line"><span>$ docker yun -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root mysql:5.6</span></span></code></pre></div><p>启动mysql 开放端口映射(3306) 指定root用户密码 -e MYSQL_ROOT_PASSWORD=xxx 后台运行 -d 指定名称 --name</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span># 后台启动</span></span>
<span class="line"><span>$ docker run -p 3306:3306 -e  MYSQL_ROOT_PASSWORD=root -d --name mysql01 mysql:5.6</span></span></code></pre></div><p>启动mysql 开放端口映射(3306) 指定root用户密码 -e MYSQL_ROOT_PASSWORD=xxx 后台运行 -d 指定名称 --name 总是运行 --restart=always</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span># 开机自启动  系统重启docker docker容器也跟着启动</span></span>
<span class="line"><span>#命令 `--restart=always`</span></span>
<span class="line"><span>$ docker run -p 3306:3306 -e  MYSQL_ROOT_PASSWORD=root -d --name mysql02  --restart=always mysql:5.6</span></span></code></pre></div><p>启动mysql 开放端口映射(3306) 指定root用户密码 -e MYSQL_ROOT_PASSWORD=xxx 后台运行 -d 指定名称 --name 总是运行 --restart=always 数据卷持久化数据到宿主机</p><p><strong>重要</strong></p><p><code>推荐使用此方法</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span># 数据同步到宿主机</span></span>
<span class="line"><span># -v 宿主机地址:容器地址</span></span>
<span class="line"><span>$ docker run -p 3306:3306 -e  MYSQL_ROOT_PASSWORD=root -d --name mysql02  --restart=always -v /root/data:/var/lib/mysql mysql:5.6</span></span></code></pre></div></li><li><p>docker 运行mysql容器数据备份</p><blockquote><p>生产服务器：linux centos系统 【宿主机】</p><p>内部有：docker引擎</p><p>mysql容器在docker引擎之上</p></blockquote><ol><li><p>在使用mysql容器时数据卷虽然能备份数据</p><p>注意：数据卷将数据库底层文件系统进行备份</p><p>数据卷只能完成当前宿主机与数据库之间的数据存储，跨机器就实现不了。</p><p>不利于诗句迁移和备份，推荐使用sql文件形式去备份数据</p></li><li><p>如何在mysql中导出sql文件来备份文件</p><blockquote><p>提示： |表示或者的意思，可以使用容器的id</p></blockquote><ol><li><p>方式一：利用mysql官方命令<code>mysqldump</code> 完成信息的备份</p><ol><li><p>备份全部数据</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ mysqldump --all-databases -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot; &gt; /root/all-databases.sql # mysql的命令</span></span>
<span class="line"><span>$ docker exec mysql|容器id sh -c &#39;exec mysqldump --all-databases -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#39; &gt; /root/all-databases.sql  # docker命令</span></span></code></pre></div></li><li><p>备份指定库数据</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker exec mysql|容器id sh -c &#39;exec mysqldump -databases -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#39; &gt; /root/xx-databases.sql  #docker命令</span></span></code></pre></div></li><li><p>备份指定库中的结构，不要数据</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker exec mysql|容器id sh -c &#39;exec mysqldump --no-data -databases -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#39; &gt; /root/xx-databases.sql  #docker命令</span></span></code></pre></div></li></ol></li><li><p>使用navicat提供数据备份进行备份</p><p>打开软件，连接数据库，找到数据表邮件选择转存储，仅结构</p><blockquote><p>直接在对应库选择备份的表即可，导出即可。</p></blockquote></li></ol></li></ol></li></ol><h3 id="docker安装redis服务" tabindex="-1"><strong>docker安装redis服务</strong> <a class="header-anchor" href="#docker安装redis服务" aria-label="Permalink to &quot;**docker安装redis服务**&quot;">​</a></h3><blockquote><p>建议：使用任何容器参考dockerhub官方网站+搜索引擎(百度google)</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>redis支持内存数据持久化</span></span></code></pre></div><ul><li><code>aof持久化</code> redis服务器将所有redis客户端的写操作以命令方式记录到日志文件中 <code>aof更安全</code></li><li><code>rdb持久化</code> 快照 redis服务器将某一时刻数据以快照文件形式写入到磁盘</li></ul></blockquote><ol><li><p>下载redis</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker pull redis:5.0.12</span></span></code></pre></div></li><li><p>运行redis</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker run -p 6379:6379 redis:5.0.12</span></span>
<span class="line"><span># 后台运行 映射端口(6379) 后台启动 -d 指定名称 --name 总是启动 --restart=always</span></span>
<span class="line"><span>$ docker run -d -p 6379:6379 --name redis01 --restart=always redis:5.0.12</span></span></code></pre></div></li><li><p>docker 运行redis如何开启持久化</p><p><code>注意</code> 只要开启了持久化，持久化文件生成在容器中的<code>/data</code>目录中</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span># 后台运行 映射端口(6379) 后台启动 -d 指定名称 --name 总是启动 --restart=always 开启持久化 --appendonly yes</span></span>
<span class="line"><span>$ docker run  -d -p 6379:6379 --name redis01 --restart=always --appendonly yes redis:5.0.12</span></span></code></pre></div></li><li><p>docker 启动redis 开放端口 后台启动 指定名称 总是启动 开启持久化 映射数据文件外部</p><p><code>注意</code> 使用此命令后！如果把redis容器删除了，也可以把数据恢复回来</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker run --name redis03 -d -p 6379:6379 --restart=always -v /root/redisdata:/data redis-server --appendonly yes redis:5.0.12</span></span></code></pre></div></li><li><p>docker 启动redis 使用配置文件启动</p><ul><li>如何获取redis配置文件 <ul><li>第一种方式：下载对应版本找到配置文件，进行修改 使用完整配置文件启动 <code>不推荐</code></li><li>第二种方式：创建指定的文件名称，直接书写修改属性即可 <code>推荐</code></li></ul></li><li>上传配置文件到宿主机指定目录 /root/redisconf/redis.conf</li><li>数据卷挂载配置启动</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker run --name redis03 -d -p 6379:6379 --restart=always -v /root/redisconf:/data redis-server /data/redis.conf --appendonly yes redis:5.0.12</span></span></code></pre></div></li></ol><h3 id="docker-运行-nginx服务" tabindex="-1"><strong>docker 运行 nginx服务</strong> <a class="header-anchor" href="#docker-运行-nginx服务" aria-label="Permalink to &quot;**docker 运行 nginx服务**&quot;">​</a></h3><blockquote><p>注意 下载nginx时， 先确定下载版本， 按照docker pull nginx:版本号 去下载</p></blockquote><ol><li><p>下载 nginx</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker pull nginx</span></span></code></pre></div></li><li><p>运行 nginx</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span># 启动nginx 映射端口(80)</span></span>
<span class="line"><span>$ docker run -p 80:80 nginx</span></span>
<span class="line"><span># 启动nginx 映射端口(80) 后台启动 总是启动 指定名称</span></span>
<span class="line"><span>$ docker run -p 80:80 -d --restart=always --name nginx01 nginx:版本号</span></span>
<span class="line"><span># 启动nginx 映射端口(80) 后台启动 总是启动 指定名称 加载指定nginx配置启动 -v 容器(/etc/nginx/nginx.conf)</span></span>
<span class="line"><span>$ docker run -p 80:80 -d --restart=always --name nginx01 -v /root/nginxconf/nginx.conf:/etc/nginx/nginx.conf nginx:版本号</span></span></code></pre></div></li><li><p>查看nginx容器是否启动成功</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker ps</span></span></code></pre></div></li><li><p>实现反向代理 负载均衡</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span># 拷贝文件</span></span>
<span class="line"><span>$ docker cp 容器id:/etc/nginx/nginx.conf /root/nginxconf</span></span>
<span class="line"><span></span></span>
<span class="line"><span>$ docker run -p 80:80 -d --restart=always --name nginx01 -v /root/nginxconf/nginx.conf:/etc/nginx/nginx.conf nginx:版本号</span></span></code></pre></div><p>nginx作为服务器</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker run -p 80:80 -d --restart=always --name nginx01 -v /root/html :/usr/share/nginx/html nginx:版本号</span></span></code></pre></div><p>nginx作为服务器 又想改配置</p><blockquote><p>注意 -v 可以写多个，没有限制</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker run -p 80:80 -d --restart=always --name nginx01 -v /root/html :/usr/share/nginx/html -v /root/nginxconf/nginx.conf:/etc/nginx/nginx.conf nginx:版本号</span></span></code></pre></div></li></ol><h3 id="docker中安装elasticsearch服务" tabindex="-1"><strong>docker中安装Elasticsearch服务</strong> <a class="header-anchor" href="#docker中安装elasticsearch服务" aria-label="Permalink to &quot;**docker中安装Elasticsearch服务**&quot;">​</a></h3><ol><li><p>去docker hub确定版本</p></li><li><p>下载镜像</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>docker pull elasticsearch:6.8.10</span></span></code></pre></div></li><li><p>运行es</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span># 启动 es 映射端口(9200(http) 9300(tcp))</span></span>
<span class="line"><span>$ docker run -p 9200:9200 -p 9300:9300 elasticsearch:6.8.10</span></span>
<span class="line"><span># 启动 es 映射端口(9200(http) 9300(tcp)) 总是启动 指定名称</span></span>
<span class="line"><span>$ docker run -p 9200:9200 -p 9300:9300 elasticsearch:6.8.10 -d --restart=always --name=es elasticsearch:6.8.10</span></span>
<span class="line"><span># 启动 es 映射端口(9200(http) 9300(tcp)) 总是启动 指定名称 通过数据卷映射数据到宿主机 容器内数据存储目录为(/usr/share/elasticsearch/data)</span></span>
<span class="line"><span>$ docker run -p 9200:9200 -p 9300:9300 elasticsearch:6.8.10 -d --restart=always --name=es -v esdata:/usr/share/elasticsearch/data elasticsearch:6.8.10</span></span>
<span class="line"><span># 注意：es启动如果没有知名单机方式启动，默认使用集群方式启动，如果使用集群方式启动在启动时会出现如下错误：1. max virtual menory areas vm.max_map_count[65530] is too low, increase to at least[262144]</span></span>
<span class="line"><span># 解决方案：在宿主机中执行如下操作</span></span>
<span class="line"><span>#	在centos虚拟机中，修改配置susctl.conf</span></span>
<span class="line"><span>$ vim /etc/sysctl.conf</span></span>
<span class="line"><span># 加入如下配置</span></span>
<span class="line"><span>$ vm.max_map_count=262144</span></span>
<span class="line"><span># 启动配置, 使配置生效</span></span>
<span class="line"><span>$ sysctl -p</span></span>
<span class="line"><span># 启动 es 映射端口(9200(http) 9300(tcp)) 总是启动 指定名称 通过数据卷映射数据到宿主机 通过数据将配置文件映射到宿主机</span></span>
<span class="line"><span>$ docker run -p 9200:9200 -p 9300:9300 elasticsearch:6.8.10 -d --restart=always --name=es -v esdata:/usr/share/elasticsearch/data -v /root/esconfig/elasticsearch.yml:/usr/share/elasticsearch/config/ elasticsearch:6.8.10</span></span></code></pre></div></li></ol><h3 id="docker中安装mongodb数据库" tabindex="-1"><strong>docker中安装MongoDB数据库</strong> <a class="header-anchor" href="#docker中安装mongodb数据库" aria-label="Permalink to &quot;**docker中安装MongoDB数据库**&quot;">​</a></h3><ol><li><p>去docker hub确定版本</p></li><li><p>下载镜像</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>docker pull elasticsearch:6.8.10</span></span></code></pre></div></li><li><p>运行MongoDB</p></li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span># 运行</span></span>
<span class="line"><span>$ docker run -d -p 27017:27017 --name mymongo mongo:版本号</span></span>
<span class="line"><span># 查看运行日志</span></span>
<span class="line"><span>$ docker logs -f mymongo</span></span>
<span class="line"><span># 进入mongoldb容器</span></span>
<span class="line"><span>$ docker exec -it mymongo bash</span></span>
<span class="line"><span># 常见具有权限的容器</span></span>
<span class="line"><span>$ docker run --name mymongo -p 27017:27017 -d mongo --auth</span></span>
<span class="line"><span># 进入容器配置用户名和密码</span></span>
<span class="line"><span>$ mongo</span></span>
<span class="line"><span>$ use admin #选择admin库</span></span>
<span class="line"><span>$ db.createUser({user:&#39;root&#39;,pwd:&#39;root&#39;,roles:[{role:&#39;root&#39;,db:&#39;admin&#39;}]}) # 创建用户，此用户创建成功，则后续操作都需要用户认证</span></span>
<span class="line"><span>$ exit</span></span>
<span class="line"><span># 将mongodb数据目录映射到宿主机中</span></span>
<span class="line"><span>$ docker run -d -p 27017:27017 -v /root/mongo/data:/data/db --name mymongo mongo</span></span></code></pre></div><h3 id="docker中容器之间的通信-网络使用" tabindex="-1"><strong>docker中容器之间的通信 -网络使用</strong> <a class="header-anchor" href="#docker中容器之间的通信-网络使用" aria-label="Permalink to &quot;**docker中容器之间的通信 -网络使用**&quot;">​</a></h3><ol><li><p>容器间通信</p><blockquote><p>说明： 容器之间通过网络相互通信</p><p>官方说明：</p><p>当docker启动的时候，会自动在主机上创建一个docker0的虚拟网桥，实际上是linux的一个bridge，可以理解为一个软件交换机，它会在挂在到它的网口之间进行转发。</p><p>同时，docker随机分配一个本地未占用的私有网段(在RFC1918中定义)中的一个地址给<code>docker0</code>接口，比如典型的<code>172.17.42.1</code>,掩码为<code>255.255.0.0</code>。伺候启动的容器内的网口也会自动分配一个同一网段(172.17.0.0/16)的地址。</p><p>当创建一个docker容器的时候，同时会创建一个<code>veth pair</code>接口(当数据包发送到一个接口时，另外一个接口也可以受到相同的数据包)。这对接口一端在容器内，即<code>etho</code>;另一端在本地并被挂在到<code>docker0</code>网桥，名称以<code>veth</code>开头(例如：<code>vethAQI2QT</code>)。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信，docker就可以创建在主机和所有容器之间的一个虚拟的共享网络。</p></blockquote></li><li><p>网络总结</p><ol><li>默认docker在创建容器时，将所有的容器都连接到docker0网桥上。默认在docker0网桥的容器都可以使用容器内ip地址进行通信。</li><li>默认docker在创建容器时，将所有容器都连接到docker0网桥上，默认在docker0网桥的容器都可以使用容器名字进行通信</li></ol></li><li><p>自定义网桥实现网桥中一组容器的通信</p><blockquote><p>缺点：没有办法跨桥通信</p></blockquote><ol><li><p>docker中网桥类型</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>NETWORK ID     NAME      DRIVER    SCOPE</span></span>
<span class="line"><span>af94280cb29a   bridge    bridge    local</span></span>
<span class="line"><span>6762fc67bdec   host      host      local</span></span>
<span class="line"><span>2f9d4d1e4b61   none      null      local</span></span></code></pre></div><p>docker中网络类型：bridge、host、null</p></li><li><p>创建网络自定义网桥</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker network --help  # 查看network帮助</span></span>
<span class="line"><span>$ docker network create -d bridge 网络名 # 创建(默认) 网络名称</span></span>
<span class="line"><span>$ docker network ls # 查看网络</span></span>
<span class="line"><span>$ docker network inspect 网络名 # 查看某一个网络细节</span></span>
<span class="line"><span>$ docker network rm 网络名 # 删除某一个网络</span></span>
<span class="line"><span>$ docker network prune # 删除所有未被使用的网络名</span></span></code></pre></div></li><li><p>运行多个容器在指定网络中</p><ol><li><p>启动容器时明确指定容器使用哪个网络</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker run -d --network 网络名称</span></span></code></pre></div></li><li><p>启动容器之后容器加入某个网络中</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker run -d -p 8080:8080 --name tomcat01 --network ems tomcat:8.0</span></span>
<span class="line"><span>$ docker run 0d -p 8081:8080 --name tomcat01 --network ems tomcat:8.0</span></span>
<span class="line"><span>$ docker network inspect ems # 查看ems网络下的容器</span></span></code></pre></div></li></ol></li></ol></li></ol><h3 id="docker高级数据卷" tabindex="-1"><strong>docker高级数据卷</strong> <a class="header-anchor" href="#docker高级数据卷" aria-label="Permalink to &quot;**docker高级数据卷**&quot;">​</a></h3><ol><li><p>高级数据卷配置</p><blockquote><p>定义：用来实现宿主机和容器之间文件目录映射同步</p></blockquote></li><li><p>数据卷使用 -v 宿主机路径:容器内路径</p><p>注意：必须在容器首次启动时指定</p><ol><li><p>使用绝对路径数据卷</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker run -v /root/datas:/usr/local/tomcat/webapps :tomcat:8.0</span></span></code></pre></div></li><li><p>使用别名方式数据卷</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker run -v bb:/usr/local/tomcat/webapps :tomcat:8.0</span></span></code></pre></div></li></ol></li><li><p>别名到底是什么</p><p>别名代表一个docker自身维护数据卷</p><ol><li><p>查看所有docker维护数据卷</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>docker volume ls</span></span></code></pre></div></li><li><p>查看数据卷详细内容</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>docker insepct 数据卷别名、网桥名称、容器名称</span></span>
<span class="line"><span>docker network inspect 查看网桥详细</span></span>
<span class="line"><span>docker volume inspect 查看数据卷详细</span></span></code></pre></div></li><li><p>删除一个数据卷</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>docker volume rm 数据卷别名</span></span></code></pre></div></li><li><p>创建一个别名数据卷</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>docker volume create 数据卷别名</span></span></code></pre></div></li></ol></li></ol><h2 id="dockerfile-重点" tabindex="-1"><strong>Dockerfile 重点</strong> <a class="header-anchor" href="#dockerfile-重点" aria-label="Permalink to &quot;**Dockerfile 重点**&quot;">​</a></h2><h3 id="什么是dockerfile" tabindex="-1"><strong>什么是Dockerfile</strong> <a class="header-anchor" href="#什么是dockerfile" aria-label="Permalink to &quot;**什么是Dockerfile**&quot;">​</a></h3><blockquote><p>Dockerfile可以认为是docker镜像的描述文件，是由一系列命令和参数构建成的脚本，主要作用是用来构建docker镜像的构建文件。</p></blockquote><h3 id="作用" tabindex="-1"><strong>作用</strong> <a class="header-anchor" href="#作用" aria-label="Permalink to &quot;**作用**&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>通过Dockerfile文件构建一个属于自己的镜像</span></span></code></pre></div><p>为什么要使用Dockerfile构建镜像的？</p><p>官方的镜像确实足够号了，足够适用于大多数应用程序，但是如果我们想自助机属于我们自己的业务镜像，这个时候必须自定义镜像。</p><h3 id="如何使用dockerfile构建自己的镜像" tabindex="-1"><strong>如何使用Dockerfile构建自己的镜像</strong> <a class="header-anchor" href="#如何使用dockerfile构建自己的镜像" aria-label="Permalink to &quot;**如何使用Dockerfile构建自己的镜像**&quot;">​</a></h3><ol><li><p>在指定位置创建一个Dockerfile文件</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>编写dockerfile相关语法</span></span></code></pre></div></li><li><p>通过dockerfile构建镜像</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker build -t aa:1.0 .... 指定dockerfile文件所在位置</span></span></code></pre></div></li></ol><h3 id="dockerfile构建镜像流程" tabindex="-1"><strong>Dockerfile构建镜像流程</strong> <a class="header-anchor" href="#dockerfile构建镜像流程" aria-label="Permalink to &quot;**Dockerfile构建镜像流程**&quot;">​</a></h3><blockquote><p>要求： Dockerfile一行只能写一条指令</p></blockquote><p>Dockerfile内容基础知识</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>1. 每条保留字指定都必须为大写，且后面都要跟至少一个参数。</span></span>
<span class="line"><span>2. 指领按照从上到下，顺序执行。</span></span>
<span class="line"><span>3. # 表示注释</span></span>
<span class="line"><span>4.每条指令都会创建一个新的镜像层，并对镜像进行提交。</span></span></code></pre></div><h3 id="dockerfile的保留命令" tabindex="-1"><strong>Dockerfile的保留命令</strong> <a class="header-anchor" href="#dockerfile的保留命令" aria-label="Permalink to &quot;**Dockerfile的保留命令**&quot;">​</a></h3><table><thead><tr><th>保留字</th><th>作用</th></tr></thead><tbody><tr><td>FORM</td><td>当前镜像基于哪个镜像 第一个指令必须是FORM</td></tr><tr><td>MAINTAINER</td><td>镜像维护者的姓名和邮箱地址</td></tr><tr><td>RUN</td><td>构建镜像时需要运行的指令</td></tr><tr><td>EXPOSE</td><td>当前容器对外暴露出的端口号</td></tr><tr><td>WORKDIR</td><td>指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</td></tr><tr><td>ENV</td><td>用来在构建过程中设置环境变量</td></tr><tr><td>ADD</td><td>将宿主机目录下的文件拷贝进镜像，且ADD命令会自动处理URL和解压tar包</td></tr><tr><td>COPY</td><td>类似于ADD,拷贝文件和目录到镜像中，将从构建上下文目录中&lt;原路径&gt;的文件/目录赋值到新的一层镜像内&lt;目标路径&gt;位置。</td></tr><tr><td>VOLUME</td><td>容器数据卷，用于数据保存和持久化工作</td></tr><tr><td>CMD</td><td>Dockerfile中可以有多个CMD命令，但只有最后一个有效，CMD会被docker run之后的参数替换。</td></tr><tr><td>ENTRYPOINT</td><td>指定一个容器启动时要运行的命令，ENTRYPOINT的目的和CMD一样。都是在指定容器启动程序及其参数</td></tr></tbody></table><h3 id="使用dockerfile" tabindex="-1"><strong>使用Dockerfile</strong> <a class="header-anchor" href="#使用dockerfile" aria-label="Permalink to &quot;**使用Dockerfile**&quot;">​</a></h3><ol><li><p>在宿主机的某一个文件夹里创建一个名称为Dockerfile的文件</p></li><li><p>使用编辑器工具或者vim去编写Dockerfile文件里内容</p><blockquote><p>小技巧：运行centos容器，直接进入到centos系统中</p><p><code>docker run -it centos:latest</code></p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ mkidr docker</span></span>
<span class="line"><span>$ cd docker</span></span>
<span class="line"><span>$ touch Dockerfile</span></span></code></pre></div><p>Dockerfile文件内容</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>FORM centos:latest</span></span>
<span class="line"><span>RUN</span></span></code></pre></div></li></ol><h3 id="form命令" tabindex="-1"><strong>FORM命令</strong> <a class="header-anchor" href="#form命令" aria-label="Permalink to &quot;**FORM命令**&quot;">​</a></h3><ul><li><p>基于那个镜像进行构建新的镜像，在构建时会自动从docker hub拉取base镜像，必须作为Dockfile的第一个指令出现</p></li><li><p>语法</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>FORM &lt;image&gt;</span></span>
<span class="line"><span>FORM &lt;image&gt;[:&lt;tag&gt;] # 使用版本不写为latest</span></span>
<span class="line"><span>FORM &lt;image&gt;[@&lt;digest&gt;] # 使用摘要</span></span></code></pre></div></li></ul><h3 id="maintainer命令" tabindex="-1"><strong>MAINTAINER命令</strong> <a class="header-anchor" href="#maintainer命令" aria-label="Permalink to &quot;**MAINTAINER命令**&quot;">​</a></h3><ul><li><p>镜像维护者的姓名和邮箱地址[废弃]</p></li><li><p>语法</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>MAINTAINER &lt;name&gt;</span></span></code></pre></div></li></ul><h3 id="run命令" tabindex="-1"><strong>RUN命令</strong> <a class="header-anchor" href="#run命令" aria-label="Permalink to &quot;**RUN命令**&quot;">​</a></h3><ul><li><p>RUN命令将在当前映像之上的新层中执行任何命令并提交结果，生成的提交映像将用于Dockerfile中的下一步。</p></li><li><p>语法</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>RUN&lt;command&gt;</span></span>
<span class="line"><span># RUN yum install vim</span></span></code></pre></div></li></ul><h3 id="expose命令" tabindex="-1"><strong>EXPOSE命令</strong> <a class="header-anchor" href="#expose命令" aria-label="Permalink to &quot;**EXPOSE命令**&quot;">​</a></h3><ul><li><p>EXPOSE命令 仅仅使声明当前容器中服务端口是谁</p></li><li><p>语法</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>EXPOSE 8808</span></span></code></pre></div></li></ul><h3 id="workdir命令" tabindex="-1"><strong>WORKDIR命令</strong> <a class="header-anchor" href="#workdir命令" aria-label="Permalink to &quot;**WORKDIR命令**&quot;">​</a></h3><ul><li><p>用不为DOCKERfile中任何RUN、CMD、EXPOSE、ADD指令设置工作目录。如果WORKDIR不存在，即使它没有在任何后续Dockfile指令中使用，它也将被创建。</p></li><li><p>语法</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>WORKDIR /path/to/workdir 指定原始镜像存在目录， 不存在目录</span></span>
<span class="line"><span>WORKDIR /a</span></span>
<span class="line"><span>WORKDIR b</span></span>
<span class="line"><span>WORKDIR c</span></span>
<span class="line"><span>注意：WORKDIR指令可以在Dockerfile中多次使用，如果提供了相对路径，则该路径将与先前WORKDIR指令的路径相对</span></span></code></pre></div></li></ul><h3 id="env命令" tabindex="-1"><strong>ENV命令</strong> <a class="header-anchor" href="#env命令" aria-label="Permalink to &quot;**ENV命令**&quot;">​</a></h3><ul><li><p>用来构建镜像设置环境变量，这个值将出现在构建阶段中所有的后续指令的环境中</p></li><li><p>语法</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>ENV &lt;KEY&gt; &lt;VALUE&gt;</span></span>
<span class="line"><span>ENV &lt;KEY&gt; = &lt;VALUE&gt;</span></span>
<span class="line"><span># 声明变量</span></span>
<span class="line"><span>ENV A = /home</span></span>
<span class="line"><span># 如何使用变量</span></span>
<span class="line"><span>WORKDIR $ A</span></span></code></pre></div></li></ul><h3 id="add命令" tabindex="-1"><strong>ADD命令</strong> <a class="header-anchor" href="#add命令" aria-label="Permalink to &quot;**ADD命令**&quot;">​</a></h3><ul><li><p>用来从context上下文复制新文件、目录或远程文件url，并将他们添加到位于指定路径的映像文件系统中。</p></li><li><p>语法</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>ADD home* /mydir/ 通配符添加多个文件</span></span>
<span class="line"><span>ADD hom?.txt /mydir/ 通配符添加</span></span>
<span class="line"><span>ADD test.txt relativeDir/ 可以指定相对路径</span></span></code></pre></div></li></ul><h3 id="cmd-entrypint作用" tabindex="-1"><strong>CMD &amp;ENTRYPINT作用</strong> <a class="header-anchor" href="#cmd-entrypint作用" aria-label="Permalink to &quot;**CMD &amp;ENTRYPINT作用**&quot;">​</a></h3><p>作用：都是用来指定容器启动时默认执行指令</p><p>注意：CMD指令可以存在多个，但是存在多个只有最后一个生效</p><p>使用语法</p><p>CMD &amp;ENTRYPOINT</p><ul><li><p>直接命令方式</p><p>java -jar ems.jar</p></li><li><p>json 数组方式</p><p>[&quot;java&quot;, &quot;-jar&quot;, &quot;ems.jar&quot;]</p></li></ul><h3 id="docker自定义项目镜像" tabindex="-1"><strong>Docker自定义项目镜像</strong> <a class="header-anchor" href="#docker自定义项目镜像" aria-label="Permalink to &quot;**Docker自定义项目镜像**&quot;">​</a></h3><ol><li>创建项目</li><li>开发项目功能，连接配置数据库，代码生成</li><li>测试项目代码</li><li>打包项目</li><li>编写Dockerfile生成项目【核心步骤】</li><li>运行镜像</li></ol><p>现有docker进行项目部署存在问题</p><p>一个项目会存在多个容器， 但是每个容器之间存在着启动的依赖关系。</p><p>为了完成一个完整的项目势必用到N个容器配合完成项目中业务开发。</p><p><strong>容器的编排至关重要</strong></p><p>现在这种方式使用容器，没有办法站在项目的角度将一个项目用到一组容器划分到一起，日后难点在于项目多服务器部署</p><p><strong>项目角度管理项目用到一组容器</strong></p><h3 id="docker-compose" tabindex="-1"><strong>Docker Compose</strong> <a class="header-anchor" href="#docker-compose" aria-label="Permalink to &quot;**Docker Compose**&quot;">​</a></h3><blockquote><p>作用：给容器进行编排，针对多个容器进行编排，单个容器不需要使用它。</p></blockquote><ol><li><p><strong>简介</strong></p><p><code>compose</code>项目时Docker官方的开源项目，负责实现对Docker容器集群的快速编排，从功能上看，跟<code>Openstack</code>中的<code>Heat</code>十分类似。</p><p>其代码目前在<a href="https://github.com/docker/compose%E4%B8%8A%E5%BC%80%E6%BA%90%E3%80%82" target="_blank" rel="noreferrer">https://github.com/docker/compose上开源。</a></p><p><code>compose</code>定位是【定义和运行多个Docker容器的应用】其前身是开源项目FIG。</p><p>通过介绍，我们知道使用一个<code>Dockerfile</code>模板文件，可以让用户很方便的定义一个单独的应用容器，然而在日常工作中，经常会配到需要多个容器相互配合来完成某项任务的情况。</p><p>例如：要实现一个web项目，除了web服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p><p><code>compose</code> 刚好满足这样的需求，它允许用户通过一个单独的<code>docker-compose.yml</code>模板文件来定义一组相关联的应用容器为一个项目。</p><p><code>compose</code>中有两个重要的概念</p><ul><li>服务：一个应用容器，实际上可以包括若干运行相同镜像的容器实例。</li><li>项目：由一组关联的应用容器组成一个完整业务单元，在<code>docker-compose.yml</code>文件中定义。</li></ul><p><code>compose</code>的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷的生命周期管理。</p><p><code>compose</code>项目有Python编写，实现上调佣了docker服务提供的API来对容器进行管理。因此，只要所操作的平台支持docker api 就可以在其上利用<code>compose</code>来进行编排管理。</p></li><li><p><strong>安装与卸载</strong></p><ol><li><p>在线安装</p><ul><li><p>从官方github release处直接下载编译好的二进制文件即可，</p></li><li><p>在linux64位系统中直接下载对应的二进制包</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ sudo curl -L &lt;https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`uname&gt; -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span></span>
<span class="line"><span>$ sudo chmod +x /usr/local/bin/docker-compose</span></span></code></pre></div></li></ul></li><li><p>离线安装</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span># 下载 docker-compose 脚本</span></span>
<span class="line"><span># 放入/usr/local/bin</span></span>
<span class="line"><span># sudo chmod +x /usr/local/bin/docker-compose</span></span></code></pre></div></li></ol></li><li><p><strong>docker-compose第一案例</strong></p><ul><li><p>创建第一个项目 mkdir ems</p></li><li><p>在ems目录创建一个docker-compose.yml模板文件</p></li><li><p>编辑docker-compose.yml模板文件</p><p>启动一个容器写法</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>version:&quot;3.8&quot; # docker-compose版本和docker 的版本关系,必须对应</span></span>
<span class="line"><span>services:</span></span>
<span class="line"><span>	tomcat:</span></span>
<span class="line"><span>	image: tomcat:8.0 # 代表使用哪个镜像，类似于docker run的镜像名称</span></span>
<span class="line"><span>	ports:</span></span>
<span class="line"><span>		-8080:8080 # 代表宿主机和容器中端口映射，类似于docker run -p参数 多个参数往下增加</span></span></code></pre></div><p>启动多个容器写法</p><p>tomcat和tomcat01是两个不同的容器</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>version:&quot;3.8&quot;</span></span>
<span class="line"><span>services:</span></span>
<span class="line"><span> tomcat:</span></span>
<span class="line"><span> container_name: tomcat01 # 代表给容器指定一个名称 类似与docker run --name 参数 推荐使用默认名称   不推荐填写这个配置项</span></span>
<span class="line"><span> image: tomcat:8.0 # 代表使用哪个镜像， 类似于 docker run 指定的镜像名称</span></span>
<span class="line"><span> ports: # 代表宿主机和容器中端口映射，类似于docker run -p参数</span></span>
<span class="line"><span> 	- 8080:8080</span></span>
<span class="line"><span></span></span>
<span class="line"><span> tomcat01:</span></span>
<span class="line"><span>  image: tomcat:8.0</span></span>
<span class="line"><span>  ports:</span></span>
<span class="line"><span>  	- 8081:8081</span></span>
<span class="line"><span> redis:</span></span>
<span class="line"><span>  image: redis:5.0.12</span></span>
<span class="line"><span>  ports:</span></span>
<span class="line"><span>   - &quot;6379:6379&quot;</span></span>
<span class="line"><span> mysql:</span></span>
<span class="line"><span>  image: mysql:5.6</span></span>
<span class="line"><span>  ports:</span></span>
<span class="line"><span>   - &quot;3306:3306&quot;</span></span>
<span class="line"><span>  environment: # 代表给当前容器启动指定环境，类似于docker run -e MYSQL_ROOT_PASSWORD=ROOT</span></span>
<span class="line"><span>   - &quot;MYSQL_ROOT_PASSWORD=root&quot;</span></span>
<span class="line"><span>  volumes: # 代表给当前容器和宿主机指定数据卷，类似于 docker run -v  用于数据持久化存储 注意：docker-compose使用绝对路径必须要有文件夹存在，如果不存在要先创建才能使用。</span></span>
<span class="line"><span>   - /root/mysqldata1:/var/lib/mysql</span></span>
<span class="line"><span>   - mysqlData: /var/lib/mysql # 也可以使用别名方式, 但要使用mysqlData必须要声明数据卷,下面就是声明 mysqlData</span></span>
<span class="line"><span>  volumes:</span></span>
<span class="line"><span>  mysqlData: # 声明mysqlData给上面使用， 创建的时候会给加上项目名_mysqlData</span></span></code></pre></div></li><li><p>启动docker-compose一组服务</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker-compose up  #  执行运行</span></span>
<span class="line"><span>$ docker-compose down # 清除缓存</span></span></code></pre></div></li></ul></li><li><p>docker-compose 支持的全部命令</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span># 网址： &lt;https://yeasy.gitbook.io/docker_practice/install&gt;</span></span></code></pre></div><ul><li><p><strong>build指令</strong></p><blockquote><p>构建</p><p>docker build -t centos7. dockerfile</p><p>作用：通过docker-compose 在启动容器之前根据dockerfile构建镜像</p></blockquote><ul><li><p>使用方法</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>version: &quot;3.8&quot;</span></span>
<span class="line"><span># 管理一组服务</span></span>
<span class="line"><span>services:</span></span>
<span class="line"><span> tomcat:</span></span>
<span class="line"><span> 	image: tomcat:8.0</span></span>
<span class="line"><span> 	ports:</span></span>
<span class="line"><span> 	 -&quot;8080:8080&quot;</span></span>
<span class="line"><span> apps:</span></span>
<span class="line"><span> 	build: ./ # 指定Dockerfile上下文目录【要求项目和docker-compose.yml和Dockerfile文件要在一起】 它会先找当前目录下的Dockerfile文件里的配置文荣执行完成，在执行docker-compose.yml</span></span>
<span class="line"><span> 	 context: ./ # 用来指定Dockerfile上下文目录</span></span>
<span class="line"><span> 	 dockerfile: Dockerfile # 指定Dockerfile文件名称</span></span>
<span class="line"><span> 	ports:</span></span>
<span class="line"><span> 	 - &quot;8081:8081&quot;</span></span></code></pre></div></li></ul></li><li><p><strong>Command指令</strong></p><blockquote><p>作用：覆盖容器启动后默认执行的命令</p></blockquote><ul><li><p>使用方法</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>version: &quot;3.8&quot;</span></span>
<span class="line"><span># 管理一组服务</span></span>
<span class="line"><span>services:</span></span>
<span class="line"><span> tomcat:</span></span>
<span class="line"><span> 	image: tomcat:8.0</span></span>
<span class="line"><span> 	ports:</span></span>
<span class="line"><span> 	 -&quot;8080:8080&quot;</span></span>
<span class="line"><span> apps:</span></span>
<span class="line"><span> 	build: ./ # 指定Dockerfile上下文目录【要求项目和docker-compose.yml和Dockerfile文件要在一起】 它会先找当前目录下的Dockerfile文件里的配置文荣执行完成，在执行docker-compose.yml</span></span>
<span class="line"><span> 	 context: ./ # 用来指定Dockerfile上下文目录</span></span>
<span class="line"><span> 	 dockerfile: Dockerfile # 指定Dockerfile文件名称</span></span>
<span class="line"><span> 	ports:</span></span>
<span class="line"><span> 	 - &quot;8081:8081&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span> 	command:[&quot;ls&quot;] # 用来覆盖容器启动后默认指令， 类似于docker image run</span></span></code></pre></div></li></ul></li><li><p><strong>container_name指令</strong></p><blockquote><p>作用：用来指定docker-compose启动容器名称 【不推荐指定容器名称】</p></blockquote></li><li><p><strong>depends_on指令</strong></p><blockquote><p>作用：解决容器的依赖、启动先后的问题</p></blockquote><ul><li><p>使用方法</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>version: &quot;3.8&quot;</span></span>
<span class="line"><span># 管理一组服务</span></span>
<span class="line"><span>services:</span></span>
<span class="line"><span> tomcat:</span></span>
<span class="line"><span> 	image: tomcat:8.0</span></span>
<span class="line"><span> 	ports:</span></span>
<span class="line"><span> 	 -&quot;8080:8080&quot;</span></span>
<span class="line"><span> apps:</span></span>
<span class="line"><span> 	build: ./ # 指定Dockerfile上下文目录【要求项目和docker-compose.yml和Dockerfile文件要在一起】 它会先找当前目录下的Dockerfile文件里的配置文荣执行完成，在执行docker-compose.yml</span></span>
<span class="line"><span> 	 context: ./ # 用来指定Dockerfile上下文目录</span></span>
<span class="line"><span> 	 dockerfile: Dockerfile # 指定Dockerfile文件名称</span></span>
<span class="line"><span> 	ports:</span></span>
<span class="line"><span> 	 - &quot;8081:8081&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span> 	command:[&quot;ls&quot;] # 用来覆盖容器启动后默认指令， 类似于docker run image  覆盖的命令</span></span>
<span class="line"><span></span></span>
<span class="line"><span> 	depends_on:</span></span>
<span class="line"><span> 		-tomcat # 书写依赖的服务</span></span>
<span class="line"><span> 		-mysql</span></span>
<span class="line"><span> 		-redis</span></span></code></pre></div></li></ul></li><li><p><strong>environment指令</strong></p><blockquote><p>作用： 用来给容器启动指定环境变量 相当于docker run -e 选项</p></blockquote></li><li><p><strong>env指令</strong></p><blockquote><p>作用：用来给容器启动 指定启动文件， 文件里的内容是容器启动时需要使用的指令</p><p>像mysql 的MYSQL_ROOT_PASSWORD: root 指令可以写到指定的配置文件里</p></blockquote><ul><li><p>使用方法</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>version: &quot;3.8&quot;</span></span>
<span class="line"><span># 管理一组服务</span></span>
<span class="line"><span>services:</span></span>
<span class="line"><span> tomcat:</span></span>
<span class="line"><span> 	image: tomcat:8.0</span></span>
<span class="line"><span> 	ports:</span></span>
<span class="line"><span> 	 -&quot;8080:8080&quot;</span></span>
<span class="line"><span> apps:</span></span>
<span class="line"><span> 	build: ./ # 指定Dockerfile上下文目录【要求项目和docker-compose.yml和Dockerfile文件要在一起】 它会先找当前目录下的Dockerfile文件里的配置文荣执行完成，在执行docker-compose.yml</span></span>
<span class="line"><span> 	 context: ./ # 用来指定Dockerfile上下文目录</span></span>
<span class="line"><span> 	 dockerfile: Dockerfile # 指定Dockerfile文件名称</span></span>
<span class="line"><span> 	ports:</span></span>
<span class="line"><span> 	 - &quot;8081:8081&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span> 	command:[&quot;ls&quot;] # 用来覆盖容器启动后默认指令， 类似于docker run image  覆盖的命令</span></span>
<span class="line"><span></span></span>
<span class="line"><span> 	depends_on:</span></span>
<span class="line"><span> 		-tomcat # 书写依赖的服务</span></span>
<span class="line"><span> 		-mysql</span></span>
<span class="line"><span> 		-redis</span></span>
<span class="line"><span></span></span>
<span class="line"><span> mysql:</span></span>
<span class="line"><span>  image: mysql:5.6</span></span>
<span class="line"><span>  ports:</span></span>
<span class="line"><span>   - &quot;3306:3306&quot;</span></span>
<span class="line"><span>  environment:</span></span>
<span class="line"><span>   MYSQL_ROOT_PASSWORD: root</span></span>
<span class="line"><span>  env_file:</span></span>
<span class="line"><span>   - ./aa.env</span></span></code></pre></div></li></ul></li><li><p><strong>expose指令</strong></p><blockquote><p>作用： 用来指定构建惊喜哪个过程中容器暴露的端口号</p></blockquote><p>使用方法</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>version: &quot;3.8&quot;</span></span>
<span class="line"><span># 管理一组服务</span></span>
<span class="line"><span>services:</span></span>
<span class="line"><span> tomcat:</span></span>
<span class="line"><span> 	image: tomcat:8.0</span></span>
<span class="line"><span> 	ports:</span></span>
<span class="line"><span> 	 -&quot;8080:8080&quot;</span></span>
<span class="line"><span> apps:</span></span>
<span class="line"><span> 	build: ./ # 指定Dockerfile上下文目录【要求项目和docker-compose.yml和Dockerfile文件要在一起】 它会先找当前目录下的Dockerfile文件里的配置文荣执行完成，在执行docker-compose.yml</span></span>
<span class="line"><span> 	 context: ./ # 用来指定Dockerfile上下文目录</span></span>
<span class="line"><span> 	 dockerfile: Dockerfile # 指定Dockerfile文件名称</span></span>
<span class="line"><span> 	ports:</span></span>
<span class="line"><span> 	 - &quot;8081:8081&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span> 	command:[&quot;ls&quot;] # 用来覆盖容器启动后默认指令， 类似于docker run image  覆盖的命令</span></span>
<span class="line"><span></span></span>
<span class="line"><span> 	depends_on:</span></span>
<span class="line"><span> 		-tomcat # 书写依赖的服务</span></span>
<span class="line"><span> 		-mysql</span></span>
<span class="line"><span> 		-redis</span></span>
<span class="line"><span></span></span>
<span class="line"><span> mysql:</span></span>
<span class="line"><span>  image: mysql:5.6</span></span>
<span class="line"><span>  ports:</span></span>
<span class="line"><span>   - &quot;3306:3306&quot;</span></span>
<span class="line"><span>  environment:</span></span>
<span class="line"><span>   MYSQL_ROOT_PASSWORD: root</span></span>
<span class="line"><span>  env_file:</span></span>
<span class="line"><span>   - ./aa.env</span></span>
<span class="line"><span>  expore: &quot;8080:8080&quot;</span></span></code></pre></div></li><li><p><strong>image指令</strong></p><blockquote><p>作用：用来指定启动容器使用镜像是谁，相当于 docker run image(镜像名)</p></blockquote></li><li><p><strong>label指令</strong></p><blockquote><p>作用： 用来添加元信息，给人看的信息</p></blockquote></li><li><p><strong>networks指令</strong></p><blockquote><p>作用： 用来指定容器所使用的网桥是什么，需要配合声明使用</p></blockquote><p>使用方法</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span># 指定使用网桥</span></span>
<span class="line"><span>networks:</span></span>
<span class="line"><span> -dangdang</span></span>
<span class="line"><span># 声明网桥名称为dangdang</span></span>
<span class="line"><span>networks:</span></span>
<span class="line"><span> dangdang:</span></span></code></pre></div></li><li><p><strong>ports指令</strong></p><blockquote><p>作用： 用来指定宿主机和容器的映射端口 相当于docker run -p</p></blockquote><p>使用方法</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>ports:</span></span>
<span class="line"><span> -&quot;3300&quot;</span></span>
<span class="line"><span> -&quot;8080:8080&quot;</span></span>
<span class="line"><span> -&quot;49100:22&quot;</span></span>
<span class="line"><span> -&quot;127.0.0.1:8001:8001&quot;</span></span></code></pre></div></li><li><p><strong>volumes指令</strong></p><blockquote><p>作用： 用来指定容器中目录和宿主机目录的映射 相当于docker run -v</p></blockquote><p>使用方法</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span># 使用数据卷</span></span>
<span class="line"><span>volumes:</span></span>
<span class="line"><span> -mysqlData:/var/lib/mysql</span></span>
<span class="line"><span># 声明别名数据卷</span></span>
<span class="line"><span>volumes:</span></span>
<span class="line"><span> mysqlData:</span></span></code></pre></div></li><li><p><strong>restart指令</strong></p><blockquote><p>作用： 用来指定docker容器(服务)总是运行 docker run --restart=always</p></blockquote></li></ul></li><li><p>docker-compose 相关指令</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>docker-compose 命令 项目|项目中某个服务，注意：没有特殊说明时，默认都是对项目操作</span></span></code></pre></div><p>语法：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>docker-compose -f docker-compose.yml 命令 【选项】【服务id】</span></span></code></pre></div><p><strong>up [重点]</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker-compose up # 对整个项目操作</span></span>
<span class="line"><span>$ docker-compose up 服务id # 对当前docker-compose中对应服务id容器操作</span></span></code></pre></div><ul><li>该命令十分强大，它将尝试自动完成包括构建镜像，重新创建服务，启动服务，并关联服务相关容器的一系列操作。</li><li>链接的服务都将会被自动启动，除非已经处于运行状态。</li><li>大部分的时候都可以直接通过该命令来启动一个项目。</li><li>默认情况下，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的数据信息，可以很方便进行调试。</li><li>当通过<code>ctrl+c</code>停止命令时，所有容器将会停止。</li><li>如果使用<code>docker-compose up -d</code>，将会在后台启动并运行所有的容器，一般<strong>推荐生产环境</strong>下使用该选项。</li><li>默认情况下，如果服务容器已经存在，<code>docker-compose up</code>将会尝试停止容器，然后重新创建(保持使用volumes-from挂载的卷)，以保证新启动的服务匹配<code>docker-compose.yml</code>文件的最新内容。</li></ul><p><strong>down[重点]</strong></p><ul><li><p>注意：<code>docker-compose down 关闭所有容器</code></p></li><li><p>此命令将会停止<code>up</code>命令所启动的容器，并移除网络</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker-compose down # 对整个项目操作</span></span>
<span class="line"><span>$ docker-compose down 服务id # 对服务id操作有效 并移除网络</span></span></code></pre></div></li></ul><p><strong>exec</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker-compose exec 服务id bash # 进入容器</span></span></code></pre></div><p><strong>ps</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker-compose ps # 展示所有运行的服务</span></span>
<span class="line"><span>$ docker-compose ps -q</span></span></code></pre></div><p><strong>restart</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker-compose restart # 项目服务重启</span></span>
<span class="line"><span>$ docker-compose restart 服务id # 对指定项目服务重启</span></span>
<span class="line"><span>$ docker-compose restart -t 20s 服务id # 在指定时间对指定项目服务重启【20秒之后重启服务】</span></span></code></pre></div><p><strong>rm</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker-compose rm # 删除整个项目</span></span>
<span class="line"><span>$ docker-compose rm 服务id # 删除指定项目服务</span></span>
<span class="line"><span># -f</span></span>
<span class="line"><span>$ docker-compose rm -f 服务id # 强制删除</span></span>
<span class="line"><span>#-v [谨慎使用]</span></span>
<span class="line"><span>$ docker-compose rm -v 服务id # 删除，会把项目的数据卷删除</span></span></code></pre></div><p><strong>top</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker-compose top # 查看整个项目中所有服务容器内运行进程</span></span>
<span class="line"><span>$ docker-compose top 服务id # 查看某个服务的运行进程</span></span></code></pre></div><p><strong>unpause</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker-compose unpause # 恢复处于暂停状态的服务</span></span>
<span class="line"><span>$ docker-compose unpause 服务id # 恢复某个服务</span></span></code></pre></div><p><strong>pause</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker-compose pause # 暂停所有服务</span></span>
<span class="line"><span>$ docker-compose pause 服务id # 暂停某个服务</span></span></code></pre></div><p><strong>logs</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker-compose logs # 查看整个项目日志</span></span>
<span class="line"><span>$ docker-compose logs 服务id # 查看某个服务的日志</span></span>
<span class="line"><span># -f 实时</span></span>
<span class="line"><span>$ docker-compose -f #实时查看整个项目日志</span></span>
<span class="line"><span>$docker-compose -f 服务id #实时查看某个服务日志</span></span></code></pre></div></li></ol><h3 id="docker可视化界面工具" tabindex="-1"><strong>Docker可视化界面工具</strong> <a class="header-anchor" href="#docker可视化界面工具" aria-label="Permalink to &quot;**Docker可视化界面工具**&quot;">​</a></h3><blockquote><p>第三方公司开源portainer项目，用来对docker引擎中运行所有容器进行可视化的展示</p></blockquote><p><strong>使用</strong></p><ul><li><p>安装Portainer</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker pull portainer/portainer</span></span>
<span class="line"><span>$ docker volume create portainer_data</span></span>
<span class="line"><span>$ docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer</span></span>
<span class="line"><span>$ docker ps</span></span></code></pre></div></li><li><p>浏览器登录</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>&lt;https://localhost:9000&gt;</span></span></code></pre></div></li></ul><h3 id="docker报错" tabindex="-1"><strong>Docker报错</strong> <a class="header-anchor" href="#docker报错" aria-label="Permalink to &quot;**Docker报错**&quot;">​</a></h3><ol><li>第一种报错</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>[root@VM-16-11-centos ~]# docker run -p 6379:6379 redis</span></span>
<span class="line"><span>docker: Error response from daemon: driver failed programming external connectivity on endpoint awesome_kare (a692caa9c368942329b345dd4aff29e89cb76644e0298847008c26c1c5af3f68):  (iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 6379 -j DNAT --to-destination 172.17.0.2:6379 ! -i docker0: iptables: No chain/target/match by that name.</span></span></code></pre></div><p>原因：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span># docker容器底层原理：在启动docker的时候会自动在iptables中注册一个链，通过防火墙的链也可以找到其注册的信息，主要注册这些链，是docker的容器为了暴露端口而使用的。</span></span>
<span class="line"><span># 具体原因是：删除了iptables中的链</span></span>
<span class="line"><span># 删除连接的方式有很多种</span></span>
<span class="line"><span># 重启firewalld防火墙即可对其清除，firewalld是centos7以上，iptables是centos6以下都会有，而firewalld的底层是涉及在iptables上的，在启动firewalld的时候会自动删除iptables链的相关链接</span></span>
<span class="line"><span># 删除该链接的其他方式博主暂未遇到有特殊情况的，待发现</span></span>
<span class="line"><span># 所以在涉及防火墙firewalld的命令或者是iptables中的命令的时候</span></span>
<span class="line"><span># 小心删除其涉及docker的链</span></span></code></pre></div><p>解决方法：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span># 重启防火墙，</span></span>
<span class="line"><span>$ systemctl restart firewalld</span></span>
<span class="line"><span># 重启docker</span></span>
<span class="line"><span>$ systemctl restart docker</span></span>
<span class="line"><span># 查询docker的链</span></span>
<span class="line"><span>$ iptables -L</span></span></code></pre></div><ul><li><strong>第二种报错</strong></li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ docker run -it centos</span></span>
<span class="line"><span># 执行上面的命令进入到了docker centos容器系统里</span></span>
<span class="line"><span># 进入到centos 在执行下面命令时报错</span></span>
<span class="line"><span>$ yum update</span></span>
<span class="line"><span># 报错</span></span>
<span class="line"><span>Failed to set locale, defaulting to C.UTF-8</span></span>
<span class="line"><span>CentOS Linux 8 - AppStream                                                                                                                                                            11  B/s |  38  B     00:03</span></span>
<span class="line"><span>Error: Failed to download metadata for repo &#39;appstream&#39;: Cannot prepare internal mirrorlist: No URLs in mirrorlist</span></span></code></pre></div><p><strong>解决方案</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ cd /etc/yum.repos.d</span></span>
<span class="line"><span>$ mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span></span>
<span class="line"><span>curl -o /etc/yum.repos.d/CentOS-Base.repo &lt;https://mirrors.aliyun.com/repo/Centos-8.repo&gt;</span></span></code></pre></div></div></div></main><footer class="VPDocFooter" data-v-ef13635e data-v-8004f88e><!--[--><!--]--><!----><nav class="prev-next" data-v-8004f88e><div class="pager" data-v-8004f88e><!----></div><div class="pager" data-v-8004f88e><a class="VPLink link pager-link next" href="/docker/%E5%9C%A8linux%E7%B3%BB%E7%BB%9F%E5%BB%BA%E7%AB%8Bdocker%E5%AE%B9%E5%99%A8.html" data-v-8004f88e><!--[--><span class="desc" data-v-8004f88e>Next page</span><span class="title" data-v-8004f88e>在linux系统中建立docker容器</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8d7d19a data-v-69e1ae8f><div class="container" data-v-69e1ae8f><p class="message" data-v-69e1ae8f>Released under the MIT License.</p><p class="copyright" data-v-69e1ae8f>Copyright © 2024-present Liu Wei</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"css_元素权重.md\":\"CLMjV8zQ\",\"css_基础知识.md\":\"uLJUN2iZ\",\"css_媒体查询.md\":\"_vMHLABr\",\"css_帧动画.md\":\"C8AREkHD\",\"css_变形动画.md\":\"DpDJzfAE\",\"css_定位布局.md\":\"C2a4V_Nv\",\"css_数据样式.md\":\"cRqZkHH-\",\"css_弹性布局.md\":\"CSI2wCMr\",\"css_文本控制.md\":\"DCPzrAii\",\"c___基础知识.md\":\"CFN5I7fq\",\"css_浮动布局.md\":\"D_mnFg29\",\"css_栅格系统.md\":\"D2CkRPQe\",\"css_背景处理.md\":\"BBi27ap7\",\"css_过渡延迟.md\":\"CQvCqtud\",\"css_盒子模型.md\":\"s5eoC-f9\",\"docker_在linux系统建立docker容器.md\":\"D4-Tqm1Q\",\"demo.md\":\"w9hqP3yK\",\"electron_基础知识.md\":\"4FcoERcN\",\"css_选择器.md\":\"A9uY3iEd\",\"go_gin项目增加接口文档.md\":\"5P0TpwhE\",\"docker_基础知识.md\":\"C61n08Iv\",\"go_gin框架.md\":\"ElR5NRiP\",\"go_go程序的基本结构和要素.md\":\"BJCoG0Oz\",\"go_安装教程.md\":\"DdYLpUCf\",\"html_基础知识.md\":\"DQSYDX5U\",\"go_常用命令.md\":\"B_4FqkKi\",\"go_热重载.md\":\"D41eKYiN\",\"html_文本.md\":\"BGzx67yU\",\"html_表格与多媒体.md\":\"BzDrktkB\",\"html_链接与图片.md\":\"BNbCC0Kh\",\"index.md\":\"BPBjTXRT\",\"mysql_基础知识.md\":\"B2OvvHgL\",\"markdown-examples.md\":\"B3Mt5Pl-\",\"html_页面结构.md\":\"Cqaw1okg\",\"html_表单与列表.md\":\"B3l6cp-G\",\"python_python 中的模块导入和包管理.md\":\"6ShQ7LaO\",\"python_pythonwin自动化神器.md\":\"BGBLVt6A\",\"python_fastui一个顶级的pythonweb库.md\":\"_KJXMPqR\",\"python_基础知识.md\":\"B8se3nLB\",\"python_web框架_fastapi.md\":\"CBqab2rI\",\"python_python检测两个字典的差异.md\":\"DO4ltS40\",\"go_gorm框架.md\":\"C8mlYT0b\",\"python_python管理远程服务器的库.md\":\"D8ViVOEA\",\"python_django_分块上传.md\":\"BvGEGfpH\",\"nginx_基础知识.md\":\"X7G3sC6Y\",\"python_虚拟环境.md\":\"CJb4Mlhj\",\"python_自定义库.md\":\"CxIGqxsf\",\"python_django_django的终极玩法.md\":\"B2fxIxEf\",\"python_django_部署django项目.md\":\"CB6B22G9\",\"vscode_终端打开vscode.md\":\"CFuRgRz-\",\"vim_改键建议与设置参考.md\":\"BMzy1fe_\",\"python_python网页自动化工具.md\":\"DzV0Gu1X\",\"react_react中使用three.js.md\":\"epcB5WyA\",\"web3_web3简介.md\":\"BXHrBRIu\",\"vim_window环境准备.md\":\"CSiqXfMI\",\"python_web框架_fastapi的操作描述.md\":\"BFe5BDI3\",\"react_react的hooks.md\":\"Du5wGE63\",\"vim_mac环境准备.md\":\"BMbaiJjw\",\"python_django_api文档第三方包.md\":\"DqQ3SRAz\",\"python_django_基础知识.md\":\"BCLhOAux\",\"架构_基础知识.md\":\"9S7C3YmZ\",\"vim_基础知识.md\":\"DnEjV3Rx\",\"vscode_使用vscode.md\":\"CU_fFhVt\",\"react_基础知识.md\":\"Ci4KyagH\",\"python_flanker电子邮件地址验证库.md\":\"DOZaoupr\",\"vite_基础知识.md\":\"BBzzBThc\",\"go_基础知识.md\":\"C8Gy-UTE\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"THELIUWEI\",\"description\":\"THELIUWEI\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"logo\":\"/Subtract.svg\",\"search\":{\"provider\":\"local\"},\"nav\":[{\"text\":\"系统课程\",\"items\":[{\"text\":\"系统课程\",\"items\":[{\"text\":\"Architecture\",\"link\":\"/架构/基础知识\"},{\"text\":\"C++\",\"link\":\"/c++/基础知识\"},{\"text\":\"Css\",\"link\":\"/css/基础知识\"},{\"text\":\"Docker\",\"link\":\"/docker/基础知识\"},{\"text\":\"Go\",\"link\":\"/go/基础知识\"},{\"text\":\"Html\",\"link\":\"/html/基础知识\"},{\"text\":\"MySQL\",\"link\":\"/mysql/基础知识\"},{\"text\":\"Python\",\"link\":\"/python/基础知识\"},{\"text\":\"React\",\"link\":\"/react/基础知识\"},{\"text\":\"Vim\",\"link\":\"/vim/基础知识\"},{\"text\":\"Vite\",\"link\":\"/vite/基础知识\"},{\"text\":\"Vscode\",\"link\":\"/vscode/终端打开vscode\"}]}]}],\"sidebar\":{\"architecture\":[{\"text\":\"architecture\",\"items\":[{\"text\":\"基础知识\",\"link\":\"/架构/基础知识\"}]}],\"c++\":[{\"text\":\"c++\",\"items\":[{\"text\":\"基础知识\",\"link\":\"/c++/基础知识\"}]}],\"css\":[{\"text\":\"css\",\"items\":[{\"text\":\"基础知识\",\"link\":\"/css/基础知识\"},{\"text\":\"选择器\",\"link\":\"/css/选择器\"},{\"text\":\"元素权重\",\"link\":\"/css/元素权重\"},{\"text\":\"文本控制\",\"link\":\"/css/文本控制\"},{\"text\":\"盒子模型\",\"link\":\"/css/盒子模型\"},{\"text\":\"背景处理\",\"link\":\"/css/背景处理\"},{\"text\":\"数据样式\",\"link\":\"/css/数据样式\"},{\"text\":\"浮动布局\",\"link\":\"/css/浮动布局\"},{\"text\":\"定位布局\",\"link\":\"/css/定位布局\"},{\"text\":\"弹性布局\",\"link\":\"/css/弹性布局\"},{\"text\":\"变形动画\",\"link\":\"/css/变形动画\"},{\"text\":\"过渡延迟\",\"link\":\"/css/过渡延迟\"},{\"text\":\"帧动画\",\"link\":\"/css/帧动画\"},{\"text\":\"背景处理\",\"link\":\"/css/背景处理\"},{\"text\":\"媒体查询\",\"link\":\"/css/媒体查询\"}]}],\"docker\":[{\"text\":\"docker\",\"items\":[{\"text\":\"基础知识\",\"link\":\"/docker/基础知识\"},{\"text\":\"在linux系统中建立docker容器\",\"link\":\"/docker/在linux系统建立docker容器\"}]}],\"go\":[{\"text\":\"go\",\"items\":[{\"text\":\"安装教程\",\"link\":\"/go/安装教程\"},{\"text\":\"基础知识\",\"link\":\"/go/基础知识\"},{\"text\":\"常用命令\",\"link\":\"/go/常用命令\"},{\"text\":\"web框架\",\"link\":\"/go/web框架\"},{\"text\":\"orm框架\",\"link\":\"/go/orm框架\"}]}],\"html\":[{\"text\":\"HTML\",\"items\":[{\"text\":\"基础知识\",\"link\":\"/html/基础知识\"},{\"text\":\"页面结构\",\"link\":\"/html/页面结构\"},{\"text\":\"文本相关\",\"link\":\"/html/文本\"},{\"text\":\"链接与图片\",\"link\":\"/html/链接与图片\"},{\"text\":\"表单与列表\",\"link\":\"/html/表单与列表\"},{\"text\":\"表单与多媒体\",\"link\":\"/html/表格与多媒体\"}]}],\"mysql\":[{\"text\":\"mysql\",\"items\":[{\"text\":\"基础知识\",\"link\":\"/mysql/基础知识\"}]}],\"nginx\":[{\"text\":\"nginx\",\"items\":[{\"text\":\"基础知识\",\"link\":\"/nginx/基础知识\"}]}],\"python\":[{\"text\":\"python\",\"items\":[{\"text\":\"基础知识\",\"link\":\"/python/基础知识\"},{\"text\":\"虚拟环境\",\"link\":\"/python/虚拟环境\"},{\"text\":\"自定义库\",\"link\":\"/python/自定义库\"},{\"text\":\"FastUI\",\"link\":\"/python/FastUI一个顶级的PythonWeb库\"},{\"text\":\"Flanker\",\"link\":\"/python/Flanker电子邮件验证库\"},{\"text\":\"Python中的模块导入和包管理\",\"link\":\"/python/Python中的模块导入和包管理\"},{\"text\":\"Python检测两个字典的差异\",\"link\":\"/python/Python检测两个字典的差异\"},{\"text\":\"Django\",\"items\":[{\"text\":\"基础知识\",\"link\":\"/python/Django/基础知识\"}]}]}],\"react\":[{\"text\":\"react\",\"items\":[{\"text\":\"基础知识\",\"link\":\"/react/基础知识\"}]}],\"vim\":[{\"text\":\"vim\",\"items\":[{\"text\":\"基础知识\",\"link\":\"/vim/基础知识\"},{\"text\":\"改键建议与设置参考\",\"link\":\"/vim/改键建议与设置参考\"},{\"text\":\"mac环境准备\",\"link\":\"/vim/mac环境准备\"},{\"text\":\"Windows环境准备\",\"link\":\"/vim/Windows环境准备\"}]}],\"vite\":[{\"text\":\"vite\",\"items\":[{\"text\":\"基础知识\",\"link\":\"/vite/基础知识\"}]}],\"vscode\":[{\"text\":\"vscode\",\"items\":[{\"text\":\"终端打开vscode\",\"link\":\"/vscode/终端打开vsceode\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/pythonliuwei-root\"}],\"footer\":{\"message\":\"Released under the MIT License.\",\"copyright\":\"Copyright © 2024-present Liu Wei\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>